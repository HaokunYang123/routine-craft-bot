---
phase: 12-mutations-optimistic-updates
plan: 03
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - src/hooks/useAssignments.ts
  - src/hooks/useAssignments.test.tsx
autonomous: true

must_haves:
  truths:
    - "User sees checkbox update instantly when clicking task completion (no spinner wait)"
    - "User sees checkbox revert if server update fails"
    - "User sees error toast if task completion fails"
    - "User sees loading state when creating assignment"
  artifacts:
    - path: "src/hooks/useAssignments.ts"
      provides: "useMutation with optimistic updates for task completion"
      contains: "onMutate"
  key_links:
    - from: "src/hooks/useAssignments.ts"
      to: "@tanstack/react-query"
      via: "useMutation with optimistic update pattern"
      pattern: "cancelQueries.*setQueryData.*onError"
---

<objective>
Migrate useAssignments mutations to useMutation with optimistic updates for task completion.

Purpose: This is the critical optimistic update - task completion checkbox should update instantly before server confirms. The pattern follows React Query's standard onMutate/onError/onSettled approach.

Output:
- useAssignments with useMutation for createAssignment and updateTaskStatus
- updateTaskStatus uses optimistic update pattern (instant checkbox feedback)
- Rollback on error with error toast
- No toast on successful task completion (per CONTEXT.md - reduces noise)
</objective>

<execution_context>
@/Users/haokunyang/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haokunyang/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-mutations-optimistic-updates/12-CONTEXT.md
@.planning/phases/12-mutations-optimistic-updates/12-RESEARCH.md

@src/hooks/useAssignments.ts
@src/lib/queries/keys.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate createAssignment to useMutation</name>
  <files>src/hooks/useAssignments.ts</files>
  <action>
Migrate createAssignment to useMutation pattern (non-optimistic, standard invalidation):

1. Add `useMutation` import from '@tanstack/react-query'

2. Replace `createAssignment` useCallback with useMutation:
```typescript
const createAssignmentMutation = useMutation({
  mutationFn: async (input: CreateAssignmentInput) => {
    // Move ALL existing createAssignment logic here (it's extensive)
    // Keep all the console.logs for debugging
    // Return the created assignment
  },
  onSuccess: async (data, variables) => {
    const taskCount = /* calculate from variables */;
    toast({
      title: "Assignment Created",
      description: `Created ${taskCount} task instances`,
    });
    return queryClient.invalidateQueries({ queryKey: queryKeys.assignments.all });
  },
  onError: (error) => {
    handleError(error, { component: 'useAssignments', action: 'create assignment' });
  },
});
```

3. Update return object:
```typescript
return {
  loading: false,
  createAssignment: (input: CreateAssignmentInput) =>
    createAssignmentMutation.mutateAsync(input),
  isCreating: createAssignmentMutation.isPending,
  // ... other functions
};
```

Important: The createAssignment function is ~280 lines. Keep all the logic intact, just wrap it in useMutation.
  </action>
  <verify>
Run `npm run build` to verify TypeScript compiles.
Run `npm test -- --run useAssignments` to verify existing tests pass.
  </verify>
  <done>
createAssignment uses useMutation with isCreating state exposed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add optimistic updateTaskStatus mutation</name>
  <files>src/hooks/useAssignments.ts</files>
  <action>
Replace updateTaskStatus with optimistic useMutation pattern. This is the critical feature for instant checkbox feedback.

1. Define mutation input type at top of file:
```typescript
interface UpdateTaskStatusInput {
  taskId: string;
  status: "pending" | "completed" | "missed";
  note?: string;
  // Context for cache update
  assigneeId?: string;
  date?: string;
}
```

2. Create optimistic mutation:
```typescript
const updateTaskStatusMutation = useMutation({
  mutationFn: async ({ taskId, status, note }: UpdateTaskStatusInput) => {
    const updates: Record<string, unknown> = {
      status,
      completed_at: status === "completed" ? new Date().toISOString() : null,
    };
    if (note !== undefined) {
      updates.student_note = note;
    }

    const { error } = await supabase
      .from("task_instances")
      .update(updates)
      .eq("id", taskId);

    if (error) throw error;
    return { taskId, status };
  },

  onMutate: async ({ taskId, status, assigneeId, date }) => {
    // 1. Cancel any outgoing refetches to prevent overwriting optimistic update
    await queryClient.cancelQueries({ queryKey: queryKeys.assignments.all });

    // 2. Build the specific query key for this user's tasks
    const instancesKey = queryKeys.assignments.instances({
      assigneeId,
      date,
    });

    // 3. Snapshot current cache for rollback
    const previousTasks = queryClient.getQueryData<TaskInstance[]>(instancesKey);

    // 4. Optimistically update the cache
    if (previousTasks) {
      queryClient.setQueryData<TaskInstance[]>(instancesKey, (old) =>
        old?.map((t) =>
          t.id === taskId
            ? { ...t, status, completed_at: status === "completed" ? new Date().toISOString() : null }
            : t
        )
      );
    }

    // 5. Return context for rollback
    return { previousTasks, instancesKey };
  },

  onError: (err, variables, context) => {
    // Rollback to previous state
    if (context?.previousTasks) {
      queryClient.setQueryData(context.instancesKey, context.previousTasks);
    }
    // Show error toast (per CONTEXT.md)
    toast({
      title: "Error",
      description: "Couldn't save changes. Please try again.",
      variant: "destructive",
    });
  },

  onSettled: () => {
    // Always refetch to ensure server state consistency
    queryClient.invalidateQueries({ queryKey: queryKeys.assignments.all });
  },

  // Note: NO onSuccess toast per CONTEXT.md - task completion is frequent, toasts add noise
});
```

3. Update return with backward-compatible wrapper:
```typescript
updateTaskStatus: (
  taskId: string,
  status: "pending" | "completed" | "missed",
  note?: string,
  assigneeId?: string,
  date?: string
) => updateTaskStatusMutation.mutateAsync({ taskId, status, note, assigneeId, date })
    .then(() => true)
    .catch(() => false),
isUpdatingTask: updateTaskStatusMutation.isPending,
```

Key changes from current implementation:
- NO toast on success (per CONTEXT.md: "Task completion: checkbox update only, no toast")
- Error toast uses user-friendly message: "Couldn't save changes. Please try again."
- Cache update happens instantly via onMutate
- Rollback happens automatically via onError
  </action>
  <verify>
Run `npm run build` to verify TypeScript compiles.
Run `npm test -- --run useAssignments` to verify tests pass.
  </verify>
  <done>
updateTaskStatus uses optimistic useMutation with instant UI feedback and rollback on error.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for optimistic update behavior</name>
  <files>src/hooks/useAssignments.test.tsx</files>
  <action>
Add tests specifically for the optimistic update behavior:

1. Test optimistic update applies immediately:
```typescript
it('optimistically updates task status before server responds', async () => {
  // Arrange: Setup slow mutation response
  vi.mocked(supabase.from).mockReturnValue({
    update: vi.fn().mockReturnValue({
      eq: vi.fn().mockReturnValue(
        new Promise(resolve => setTimeout(() => resolve({ error: null }), 100))
      ),
    }),
  } as any);

  // Seed cache with task instances
  const queryClient = new QueryClient();
  const taskId = 'task-1';
  queryClient.setQueryData(queryKeys.assignments.instances({ assigneeId: 'user-1', date: '2026-01-27' }), [
    { id: taskId, status: 'pending', assignee_id: 'user-1' },
  ]);

  // Act: Call updateTaskStatus
  const { result } = renderHook(() => useAssignments(), {
    wrapper: createWrapper(queryClient),
  });
  result.current.updateTaskStatus(taskId, 'completed', undefined, 'user-1', '2026-01-27');

  // Assert: Cache is updated immediately (before mutation resolves)
  const cached = queryClient.getQueryData(queryKeys.assignments.instances({ assigneeId: 'user-1', date: '2026-01-27' }));
  expect(cached[0].status).toBe('completed');
});
```

2. Test rollback on error:
```typescript
it('rolls back optimistic update on error', async () => {
  // Arrange: Setup failing mutation
  vi.mocked(supabase.from).mockReturnValue({
    update: vi.fn().mockReturnValue({
      eq: vi.fn().mockResolvedValue({ error: { message: 'Server error' } }),
    }),
  } as any);

  // Seed cache
  const queryClient = new QueryClient();
  const taskId = 'task-1';
  queryClient.setQueryData(queryKeys.assignments.instances({ assigneeId: 'user-1', date: '2026-01-27' }), [
    { id: taskId, status: 'pending', assignee_id: 'user-1' },
  ]);

  // Act
  const { result } = renderHook(() => useAssignments(), { wrapper: createWrapper(queryClient) });
  await result.current.updateTaskStatus(taskId, 'completed', undefined, 'user-1', '2026-01-27');

  // Assert: Status rolled back to pending
  await waitFor(() => {
    const cached = queryClient.getQueryData(queryKeys.assignments.instances({ assigneeId: 'user-1', date: '2026-01-27' }));
    expect(cached[0].status).toBe('pending');
  });
});
```

3. Test no toast on successful completion:
```typescript
it('does not show toast on successful task completion', async () => {
  // Arrange
  const mockToast = vi.fn();
  vi.mock('./use-toast', () => ({ useToast: () => ({ toast: mockToast }) }));

  // Act: Complete a task successfully
  // ...

  // Assert: toast was NOT called for success
  expect(mockToast).not.toHaveBeenCalled();
});
```

4. Test error toast on failure:
```typescript
it('shows error toast on failed task completion', async () => {
  // Arrange: Failing mutation
  // Act: Complete task
  // Assert: toast called with destructive variant
});
```
  </action>
  <verify>
Run `npm test -- --run useAssignments` - all tests including new optimistic update tests should pass.
  </verify>
  <done>
Optimistic update behavior is thoroughly tested: instant update, rollback on error, correct toast behavior.
  </done>
</task>

</tasks>

<verification>
1. Run full test suite: `npm test -- --run`
2. Run TypeScript check: `npm run build`
3. Manual verification in dev server:
   - Click task checkbox - should update instantly (no spinner/delay)
   - Disconnect network, click checkbox - should revert after timeout with error toast
</verification>

<success_criteria>
- updateTaskStatus uses optimistic useMutation pattern
- Checkbox updates instantly on click (before server responds)
- Failed updates show error toast and revert checkbox
- No toast on successful task completion (per CONTEXT.md)
- createAssignment uses standard useMutation with isCreating state
- All tests pass including new optimistic update tests
</success_criteria>

<output>
After completion, create `.planning/phases/12-mutations-optimistic-updates/12-03-SUMMARY.md`
</output>
