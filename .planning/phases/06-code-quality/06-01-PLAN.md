---
phase: 06-code-quality
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/ui/sketch.tsx
  - src/components/MagicScheduleButton.tsx
  - src/pages/student/StudentSchedule.tsx
  - src/pages/student/StickerBook.tsx
autonomous: true

must_haves:
  truths:
    - "No React state update warnings on unmounted components from setTimeout"
    - "Navigating away during animations does not cause memory leaks"
    - "Multiple rapid clicks do not create multiple pending timeouts"
  artifacts:
    - path: "src/components/ui/sketch.tsx"
      provides: "SketchCheckbox with timeout cleanup"
      contains: "timeoutRef"
    - path: "src/components/MagicScheduleButton.tsx"
      provides: "Animation timeout cleanup"
      contains: "timeoutRef"
    - path: "src/pages/student/StudentSchedule.tsx"
      provides: "Fade animation timeout tracking"
      contains: "timeoutsRef"
    - path: "src/pages/student/StickerBook.tsx"
      provides: "Pop animation timeout cleanup"
      contains: "timeoutRef"
  key_links:
    - from: "SketchCheckbox"
      to: "useEffect cleanup"
      via: "clearTimeout on unmount"
      pattern: "return.*clearTimeout"
    - from: "StudentSchedule"
      to: "timeout Map"
      via: "per-task timeout tracking"
      pattern: "timeoutsRef\\.current\\.(get|set|delete)"
---

<objective>
Fix memory leaks from setTimeout calls without cleanup in 4 component files.

Purpose: Prevent React "Can't perform state update on unmounted component" warnings and memory leaks when users navigate away during animations.

Output: All 4 files updated with useRef timeout tracking and useEffect cleanup patterns.
</objective>

<execution_context>
@/Users/haokunyang/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haokunyang/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-code-quality/06-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix setTimeout in SketchCheckbox and MagicScheduleButton</name>
  <files>
    - src/components/ui/sketch.tsx
    - src/components/MagicScheduleButton.tsx
  </files>
  <action>
**sketch.tsx - SketchCheckbox component (line 387-429):**
1. Add `useRef` import if not present
2. Add `timeoutRef` inside SketchCheckbox:
   ```typescript
   const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
   ```
3. Add useEffect cleanup:
   ```typescript
   useEffect(() => {
     return () => {
       if (timeoutRef.current) {
         clearTimeout(timeoutRef.current);
       }
     };
   }, []);
   ```
4. Update handleClick (line 390-396):
   ```typescript
   const handleClick = () => {
     if (onChange && !disabled) {
       setAnimating(true);
       if (timeoutRef.current) {
         clearTimeout(timeoutRef.current);
       }
       timeoutRef.current = setTimeout(() => setAnimating(false), 300);
       onChange();
     }
   };
   ```

**MagicScheduleButton.tsx (line 30-47):**
1. Add `useRef, useEffect` to imports
2. Add timeout ref:
   ```typescript
   const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
   ```
3. Add useEffect cleanup after the refs:
   ```typescript
   useEffect(() => {
     return () => {
       if (timeoutRef.current) {
         clearTimeout(timeoutRef.current);
       }
     };
   }, []);
   ```
4. Update handleClick (line 42-46):
   ```typescript
   // Clear any pending timeout before setting new one
   if (timeoutRef.current) {
     clearTimeout(timeoutRef.current);
   }
   timeoutRef.current = setTimeout(() => {
     setIsAnimating(false);
     setSparkles([]);
     onMagicPlan?.();
   }, 800);
   ```
  </action>
  <verify>
    - `grep -n "timeoutRef" src/components/ui/sketch.tsx` shows ref declaration and cleanup
    - `grep -n "timeoutRef" src/components/MagicScheduleButton.tsx` shows ref declaration and cleanup
    - `npm run build` succeeds with no TypeScript errors
  </verify>
  <done>
    - SketchCheckbox stores timeout ID in ref and clears on unmount
    - MagicScheduleButton stores timeout ID in ref and clears on unmount
    - Both clear previous timeout before setting new one (handles rapid clicks)
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix setTimeout in StudentSchedule and StickerBook</name>
  <files>
    - src/pages/student/StudentSchedule.tsx
    - src/pages/student/StickerBook.tsx
  </files>
  <action>
**StudentSchedule.tsx (line 215-221 in handleToggleComplete):**
This file has multiple concurrent timeouts (one per task being completed), so needs Map-based tracking.

1. Add `useRef` to imports (line 1)
2. Add timeout Map ref after the existing useState declarations (around line 56):
   ```typescript
   const timeoutsRef = useRef<Map<string, ReturnType<typeof setTimeout>>>(new Map());
   ```
3. Add useEffect cleanup after the existing useEffect (around line 64):
   ```typescript
   useEffect(() => {
     return () => {
       timeoutsRef.current.forEach((timeout) => clearTimeout(timeout));
       timeoutsRef.current.clear();
     };
   }, []);
   ```
4. Update the setTimeout in handleToggleComplete (lines 215-221):
   ```typescript
   if (completed) {
     // Add fade-out effect before removing from view
     setFadingTasks(prev => new Set(prev).add(taskId));

     toast({
       title: "Nice work!",
       description: "Task marked as complete.",
     });

     // Clear any existing timeout for this task
     const existing = timeoutsRef.current.get(taskId);
     if (existing) clearTimeout(existing);

     // Remove from fading set after animation completes
     const timeout = setTimeout(() => {
       setFadingTasks(prev => {
         const newSet = new Set(prev);
         newSet.delete(taskId);
         return newSet;
       });
       timeoutsRef.current.delete(taskId);
     }, 1000);

     timeoutsRef.current.set(taskId, timeout);
   }
   ```

**StickerBook.tsx - StickerCard component (line 194-256):**
1. Add `useRef, useEffect` to imports at top of file (line 1)
2. Inside StickerCard function, add timeout ref after useState (line 196):
   ```typescript
   const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
   ```
3. Add useEffect cleanup:
   ```typescript
   useEffect(() => {
     return () => {
       if (timeoutRef.current) {
         clearTimeout(timeoutRef.current);
       }
     };
   }, []);
   ```
4. Update handleClick (line 199-205):
   ```typescript
   const handleClick = () => {
     if (!isLocked) {
       setShowPop(true);
       if (timeoutRef.current) {
         clearTimeout(timeoutRef.current);
       }
       timeoutRef.current = setTimeout(() => setShowPop(false), 300);
     }
     onClick?.();
   };
   ```
  </action>
  <verify>
    - `grep -n "timeoutsRef" src/pages/student/StudentSchedule.tsx` shows Map ref and cleanup
    - `grep -n "timeoutRef" src/pages/student/StickerBook.tsx` shows ref declaration and cleanup
    - `npm run build` succeeds with no TypeScript errors
  </verify>
  <done>
    - StudentSchedule tracks multiple concurrent timeouts per task ID in Map
    - StudentSchedule clears all pending timeouts on unmount
    - StickerCard stores timeout ID in ref and clears on unmount
    - All 4 files (QUAL-01 to QUAL-04) now have proper setTimeout cleanup
  </done>
</task>

</tasks>

<verification>
1. **Build passes:** `npm run build` completes without errors
2. **Patterns present:** All 4 files contain timeout ref declarations and cleanup logic
3. **No double timeouts:** Rapid click handling via clearTimeout before new setTimeout
4. **Map pattern for StudentSchedule:** Uses Map for per-task timeout tracking
</verification>

<success_criteria>
- [ ] sketch.tsx SketchCheckbox has timeoutRef + useEffect cleanup
- [ ] MagicScheduleButton.tsx has timeoutRef + useEffect cleanup
- [ ] StudentSchedule.tsx has timeoutsRef Map + useEffect cleanup
- [ ] StickerBook.tsx StickerCard has timeoutRef + useEffect cleanup
- [ ] All files clear previous timeout before setting new one
- [ ] `npm run build` succeeds
- [ ] Requirements QUAL-01, QUAL-02, QUAL-03, QUAL-04 satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/06-code-quality/06-01-SUMMARY.md`
</output>
