---
phase: 13-pagination
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/queries/keys.ts
  - src/hooks/useLocalStorage.ts
  - src/hooks/useInfiniteClients.ts
  - src/hooks/useInfiniteClients.test.ts
autonomous: true

must_haves:
  truths:
    - "useInfiniteClients hook returns paginated client data"
    - "Page size preference persists across browser sessions"
    - "Query key factory supports infinite client queries"
  artifacts:
    - path: "src/lib/queries/keys.ts"
      provides: "clients.all and clients.infinite query keys"
      contains: "clients:"
    - path: "src/hooks/useLocalStorage.ts"
      provides: "Persistent localStorage state hook"
      exports: ["useLocalStorage"]
    - path: "src/hooks/useInfiniteClients.ts"
      provides: "Infinite query hook for class_sessions"
      exports: ["useInfiniteClients"]
    - path: "src/hooks/useInfiniteClients.test.ts"
      provides: "Tests for infinite clients hook"
      min_lines: 80
  key_links:
    - from: "src/hooks/useInfiniteClients.ts"
      to: "src/lib/queries/keys.ts"
      via: "import queryKeys"
      pattern: "queryKeys\\.clients\\.infinite"
---

<objective>
Create the foundational infrastructure for cursor-based pagination: query key factory extension, localStorage persistence hook, and useInfiniteClients hook.

Purpose: Establish the data layer for infinite scroll without modifying existing UI.
Output: Three new/updated files providing pagination infrastructure with tests.
</objective>

<execution_context>
@/Users/haokunyang/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haokunyang/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-pagination/13-RESEARCH.md
@src/lib/queries/keys.ts
@src/hooks/useGroups.ts
@src/pages/People.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend query key factory with clients keys</name>
  <files>src/lib/queries/keys.ts</files>
  <action>
Add `clients` key hierarchy to the existing queryKeys object:

```typescript
clients: {
  all: ['clients'] as const,
  infinite: (userId: string, pageSize: number) =>
    [...queryKeys.clients.all, 'infinite', userId, pageSize] as const,
},
```

Insert after the existing `recurringSchedules` entry. The `pageSize` is included in the key so changing page size fetches fresh data (avoids cache inconsistency).
  </action>
  <verify>TypeScript compiles with `npx tsc --noEmit`</verify>
  <done>queryKeys.clients.all and queryKeys.clients.infinite are defined and type-safe</done>
</task>

<task type="auto">
  <name>Task 2: Create useLocalStorage hook</name>
  <files>src/hooks/useLocalStorage.ts</files>
  <action>
Create a generic hook for persisting state to localStorage:

```typescript
import { useState, useCallback } from 'react';

/**
 * Persist state to localStorage with automatic serialization.
 * Falls back to defaultValue if localStorage is unavailable or value is invalid.
 */
export function useLocalStorage<T>(
  key: string,
  defaultValue: T
): [T, (value: T | ((prev: T) => T)) => void] {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : defaultValue;
    } catch {
      return defaultValue;
    }
  });

  const setValue = useCallback(
    (value: T | ((prev: T) => T)) => {
      setStoredValue((prev) => {
        const newValue = value instanceof Function ? value(prev) : value;
        try {
          localStorage.setItem(key, JSON.stringify(newValue));
        } catch {
          // localStorage full or unavailable - silently fail
        }
        return newValue;
      });
    },
    [key]
  );

  return [storedValue, setValue];
}
```

This follows the pattern from RESEARCH.md but adds functional updates support.
  </action>
  <verify>TypeScript compiles with `npx tsc --noEmit`</verify>
  <done>useLocalStorage hook exists and handles both direct values and functional updates</done>
</task>

<task type="auto">
  <name>Task 3: Create useInfiniteClients hook with tests</name>
  <files>src/hooks/useInfiniteClients.ts, src/hooks/useInfiniteClients.test.ts</files>
  <action>
Create the infinite query hook following the pattern from RESEARCH.md:

**src/hooks/useInfiniteClients.ts:**

```typescript
import { useInfiniteQuery } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from './useAuth';
import { queryKeys } from '@/lib/queries/keys';

export interface Client {
  id: string;
  name: string;
  join_code: string;
  is_active: boolean;
  default_template_id: string | null;
  created_at: string;
  coach_id: string;
}

export interface ClientsPage {
  data: Client[];
  nextCursor: string | null;
  totalCount: number;
}

async function fetchClientsPage({
  pageParam,
  userId,
  pageSize,
}: {
  pageParam: string | null;
  userId: string;
  pageSize: number;
}): Promise<ClientsPage> {
  // Build query
  let query = supabase
    .from('class_sessions')
    .select('*', { count: 'exact' })
    .eq('coach_id', userId)
    .eq('is_active', true)
    .order('created_at', { ascending: false })
    .limit(pageSize);

  // Apply cursor for pagination (items OLDER than cursor)
  if (pageParam) {
    query = query.lt('created_at', pageParam);
  }

  const { data, error, count } = await query;
  if (error) throw error;

  const lastItem = data?.[data.length - 1];
  return {
    data: (data ?? []) as Client[],
    nextCursor: data && data.length === pageSize ? lastItem?.created_at ?? null : null,
    totalCount: count ?? 0,
  };
}

export function useInfiniteClients(pageSize: number = 25) {
  const { user } = useAuth();

  return useInfiniteQuery({
    queryKey: queryKeys.clients.infinite(user?.id ?? '', pageSize),
    queryFn: ({ pageParam }) =>
      fetchClientsPage({
        pageParam,
        userId: user!.id,
        pageSize,
      }),
    initialPageParam: null as string | null,
    getNextPageParam: (lastPage) => lastPage.nextCursor,
    enabled: !!user,
  });
}
```

**src/hooks/useInfiniteClients.test.ts:**

Create comprehensive tests covering:
1. Returns empty pages when user not authenticated
2. Fetches first page successfully
3. Fetches subsequent pages with cursor
4. Returns hasNextPage false when fewer items than pageSize
5. Includes totalCount in response
6. Handles Supabase errors
7. Uses correct query key with userId and pageSize

Follow the testing patterns from existing hook tests (useGroups.test.tsx, useProfile.test.tsx). Use vi.mock for Supabase, renderHook from @testing-library/react, and wrap with QueryClientProvider.
  </action>
  <verify>Run `npm test -- useInfiniteClients.test.ts` - all tests pass</verify>
  <done>useInfiniteClients hook returns paginated data with cursor-based pagination, 7+ tests pass</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - TypeScript compiles without errors
2. `npm test -- useInfiniteClients.test.ts` - All tests pass
3. Manual check: queryKeys.clients.infinite exists and is type-safe
</verification>

<success_criteria>
- Query key factory extended with clients.all and clients.infinite
- useLocalStorage hook created with TypeScript generics
- useInfiniteClients hook using useInfiniteQuery with cursor pagination
- 7+ tests for useInfiniteClients covering success and error cases
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/13-pagination/13-01-SUMMARY.md`
</output>
