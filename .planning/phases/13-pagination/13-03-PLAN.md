---
phase: 13-pagination
plan: 03
type: execute
wave: 2
depends_on: ["13-01", "13-02"]
files_modified:
  - src/pages/People.tsx
autonomous: true

must_haves:
  truths:
    - "User can select page size (10/25/50) for client list"
    - "User sees loading indicator when loading next page"
    - "User sees 'That's everything' when all items loaded"
    - "User can scroll to load more items continuously"
    - "Page size preference persists across browser sessions"
  artifacts:
    - path: "src/pages/People.tsx"
      provides: "Paginated People page using infinite scroll"
      contains: "useInfiniteClients"
  key_links:
    - from: "src/pages/People.tsx"
      to: "src/hooks/useInfiniteClients.ts"
      via: "import"
      pattern: "useInfiniteClients"
    - from: "src/pages/People.tsx"
      to: "src/hooks/useLocalStorage.ts"
      via: "import"
      pattern: "useLocalStorage"
    - from: "src/pages/People.tsx"
      to: "src/components/pagination/InfiniteScrollSentinel.tsx"
      via: "import"
      pattern: "InfiniteScrollSentinel"
    - from: "src/pages/People.tsx"
      to: "src/components/pagination/PageSizeSelector.tsx"
      via: "import"
      pattern: "PageSizeSelector"
    - from: "src/pages/People.tsx"
      to: "src/components/pagination/ListStatus.tsx"
      via: "import"
      pattern: "ListStatus"
---

<objective>
Refactor People.tsx to use infinite scroll pagination with all the infrastructure from plans 01 and 02.

Purpose: Replace the current "fetch all" pattern with paginated infinite scroll.
Output: Updated People.tsx using useInfiniteClients hook and pagination components.
</objective>

<execution_context>
@/Users/haokunyang/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haokunyang/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-pagination/13-CONTEXT.md
@.planning/phases/13-pagination/13-01-SUMMARY.md
@.planning/phases/13-pagination/13-02-SUMMARY.md
@src/pages/People.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace fetchData with useInfiniteClients</name>
  <files>src/pages/People.tsx</files>
  <action>
Refactor People.tsx to use the new infinite query hook:

1. **Add imports:**
```typescript
import { useInfiniteClients, Client } from '@/hooks/useInfiniteClients';
import { useLocalStorage } from '@/hooks/useLocalStorage';
import { InfiniteScrollSentinel } from '@/components/pagination/InfiniteScrollSentinel';
import { PageSizeSelector } from '@/components/pagination/PageSizeSelector';
import { ListStatus } from '@/components/pagination/ListStatus';
```

2. **Replace state and data fetching:**
Remove:
- `const [loading, setLoading] = useState(true);`
- `const [groups, setGroups] = useState<GroupWithStudents[]>([]);`
- The entire `fetchData` function (lines 87-140)
- The `useEffect` calling `fetchData` (lines 82-85)

Add:
```typescript
// Page size with localStorage persistence (default: 25)
const [pageSize, setPageSize] = useLocalStorage('clients-page-size', 25);

// Infinite query for clients (class_sessions)
const {
  data,
  fetchNextPage,
  hasNextPage,
  isFetchingNextPage,
  isPending,
  isError,
  error,
  refetch,
} = useInfiniteClients(pageSize);

// Flatten pages into single array
const groups = data?.pages.flatMap((page) => page.data) ?? [];
const totalCount = data?.pages[0]?.totalCount ?? 0;
```

3. **Keep the student fetching logic per group** but adapt to work with the flat groups array. The existing `GroupWithStudents` interface and per-group student fetching (via expanding groups) remains unchanged - we're only paginating the top-level groups list.

4. **Note:** The current People.tsx fetches students for ALL groups upfront in `fetchData`. With pagination, we need to fetch students lazily when a group is expanded. Keep the expansion logic but fetch students on demand instead.
  </action>
  <verify>TypeScript compiles with `npx tsc --noEmit`</verify>
  <done>Data fetching uses useInfiniteClients, groups array comes from flatMap of pages</done>
</task>

<task type="auto">
  <name>Task 2: Add pagination UI components to list</name>
  <files>src/pages/People.tsx</files>
  <action>
Integrate the pagination components:

1. **Add PageSizeSelector above the list:**
After the "New Group" button section, before the groups list:

```tsx
{groups.length > 0 && (
  <PageSizeSelector
    value={pageSize}
    onChange={setPageSize}
    totalCount={totalCount}
    loadedCount={groups.length}
  />
)}
```

2. **Add InfiniteScrollSentinel and ListStatus after the groups list:**
Inside the groups mapping section, after the last Card:

```tsx
{/* Pagination controls */}
<InfiniteScrollSentinel
  onLoadMore={fetchNextPage}
  hasMore={hasNextPage ?? false}
  isLoading={isFetchingNextPage}
/>

<ListStatus
  isLoading={isFetchingNextPage}
  hasMore={hasNextPage ?? false}
  itemCount={groups.length}
  error={isError ? (error as Error) : null}
  onRetry={() => refetch()}
/>
```

3. **Update the loading state check:**
Replace:
```tsx
if (loading) {
  return (
    <div className="flex items-center justify-center h-64">
      <Loader2 className="w-8 h-8 animate-spin text-foreground" />
    </div>
  );
}
```

With:
```tsx
if (isPending) {
  return (
    <div className="flex items-center justify-center h-64">
      <Loader2 className="w-8 h-8 animate-spin text-foreground" />
    </div>
  );
}
```
  </action>
  <verify>TypeScript compiles with `npx tsc --noEmit`</verify>
  <done>PageSizeSelector shows at top, infinite scroll and status show at bottom of list</done>
</task>

<task type="auto">
  <name>Task 3: Adapt student fetching for lazy loading</name>
  <files>src/pages/People.tsx</files>
  <action>
Since we no longer fetch all students upfront, adapt the group expansion to fetch students on demand:

1. **Update the GroupWithStudents interface usage:**
The `Client` type from useInfiniteClients doesn't include students. Create a local state to track students per group:

```typescript
// Students fetched per group (keyed by group id)
const [studentsMap, setStudentsMap] = useState<Record<string, Student[]>>({});
```

2. **Create a fetchStudentsForGroup function:**
```typescript
const fetchStudentsForGroup = async (groupId: string) => {
  // Skip if already fetched
  if (studentsMap[groupId]) return;

  try {
    const { data: connections } = await supabase
      .from('instructor_students')
      .select('id, student_id')
      .eq('class_session_id', groupId);

    let students: Student[] = [];

    if (connections && connections.length > 0) {
      const studentIds = connections.map((c: any) => c.student_id);
      const { data: profiles } = await supabase
        .from('profiles')
        .select('user_id, display_name')
        .in('user_id', studentIds);

      students = connections.map((conn: any) => {
        const profile = profiles?.find((p: any) => p.user_id === conn.student_id);
        return {
          id: conn.id,
          student_id: conn.student_id,
          display_name: profile?.display_name || 'Student',
          email: '',
        };
      });
    }

    setStudentsMap((prev) => ({ ...prev, [groupId]: students }));
  } catch (error) {
    handleError(error, { component: 'People', action: 'fetch students', silent: true });
    setStudentsMap((prev) => ({ ...prev, [groupId]: [] }));
  }
};
```

3. **Update toggleGroup to fetch students:**
```typescript
const toggleGroup = (groupId: string) => {
  const newExpanded = new Set(expandedGroups);
  if (newExpanded.has(groupId)) {
    newExpanded.delete(groupId);
  } else {
    newExpanded.add(groupId);
    // Fetch students when expanding
    fetchStudentsForGroup(groupId);
  }
  setExpandedGroups(newExpanded);
};
```

4. **Update the render to use studentsMap:**
Where we render `group.students`, use `studentsMap[group.id] ?? []` instead.

5. **Update mutation handlers:**
The handleDeleteGroup and handleRemoveStudent functions should:
- For delete: Use React Query's invalidation (the query will refetch)
- For remove student: Update studentsMap locally

```typescript
// In handleRemoveStudent success:
setStudentsMap((prev) => ({
  ...prev,
  [groupId]: (prev[groupId] || []).filter((s) => s.id !== connectionId),
}));
```

6. **Update handleCreateRoster:**
After successful creation, invalidate the query:
```typescript
import { useQueryClient } from '@tanstack/react-query';
import { queryKeys } from '@/lib/queries/keys';

// In component:
const queryClient = useQueryClient();

// In handleCreateRoster success:
queryClient.invalidateQueries({ queryKey: queryKeys.clients.all });
```
  </action>
  <verify>
1. `npx tsc --noEmit` - TypeScript compiles without errors
2. Manual verification with `npm run dev`:
   - Groups load in pages as you scroll
   - Expanding a group fetches its students
   - Creating a new group invalidates the list
   - Removing a student updates the local state
  </verify>
  <done>Students are fetched lazily when groups expand, mutations update state correctly</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - TypeScript compiles without errors
2. `npm run dev` - Application runs without console errors
3. Manual verification:
   - Page loads with first page of groups
   - Scrolling down loads more groups
   - Page size selector changes load count
   - "That's everything" shows when all loaded
   - Expanding a group fetches students
   - Creating/deleting groups updates the list
</verification>

<success_criteria>
**From REQUIREMENTS.md (PAG-01 through PAG-05):**
- PAG-01: User can control page size (10/25/50) - PageSizeSelector present
- PAG-02: User sees loading indicator when loading next page - ListStatus shows spinner
- PAG-03: User sees "That's everything" when all items loaded - ListStatus shows end message
- PAG-04: Cursor-based pagination - useInfiniteClients uses created_at cursor
- PAG-05: User can scroll to load more - InfiniteScrollSentinel triggers fetchNextPage

**From CONTEXT.md:**
- Page size persists in localStorage
- Default page size is 25
- "Showing X of Y" counter visible
</success_criteria>

<output>
After completion, create `.planning/phases/13-pagination/13-03-SUMMARY.md`
</output>
