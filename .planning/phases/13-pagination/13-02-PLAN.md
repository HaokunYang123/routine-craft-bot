---
phase: 13-pagination
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useIntersectionObserver.ts
  - src/components/pagination/InfiniteScrollSentinel.tsx
  - src/components/pagination/PageSizeSelector.tsx
  - src/components/pagination/ListStatus.tsx
autonomous: true

must_haves:
  truths:
    - "InfiniteScrollSentinel triggers callback when scrolled into view"
    - "PageSizeSelector shows options 10/25/50 with current selection"
    - "ListStatus shows loading spinner or 'That's everything' based on state"
  artifacts:
    - path: "src/hooks/useIntersectionObserver.ts"
      provides: "Hook for Intersection Observer API"
      exports: ["useIntersectionObserver"]
    - path: "src/components/pagination/InfiniteScrollSentinel.tsx"
      provides: "Invisible trigger element for infinite scroll"
      exports: ["InfiniteScrollSentinel"]
    - path: "src/components/pagination/PageSizeSelector.tsx"
      provides: "Dropdown for page size selection"
      exports: ["PageSizeSelector"]
    - path: "src/components/pagination/ListStatus.tsx"
      provides: "Loading indicator and end of list display"
      exports: ["ListStatus"]
  key_links:
    - from: "src/components/pagination/InfiniteScrollSentinel.tsx"
      to: "src/hooks/useIntersectionObserver.ts"
      via: "import"
      pattern: "useIntersectionObserver"
---

<objective>
Create reusable UI components for infinite scroll: intersection observer hook, sentinel element, page size selector, and loading/end states.

Purpose: Build isolated, reusable components that can be composed in any list view.
Output: Four new files providing pagination UI building blocks.
</objective>

<execution_context>
@/Users/haokunyang/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haokunyang/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-pagination/13-RESEARCH.md
@.planning/phases/13-pagination/13-CONTEXT.md
@src/components/ui/select.tsx
@src/components/ui/button.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useIntersectionObserver hook</name>
  <files>src/hooks/useIntersectionObserver.ts</files>
  <action>
Create a hook wrapping the native Intersection Observer API:

```typescript
import { useRef, useEffect, useCallback } from 'react';

interface UseIntersectionObserverProps {
  onIntersect: () => void;
  enabled?: boolean;
  threshold?: number;
  rootMargin?: string;
}

/**
 * Hook for observing when an element enters the viewport.
 * Used for infinite scroll to trigger loading when sentinel is visible.
 *
 * @param onIntersect - Callback fired when element enters viewport
 * @param enabled - Whether to observe (default: true)
 * @param threshold - Visibility threshold 0-1 (default: 0)
 * @param rootMargin - Margin around root (default: '100px' for preloading)
 * @returns Ref to attach to the sentinel element
 */
export function useIntersectionObserver({
  onIntersect,
  enabled = true,
  threshold = 0,
  rootMargin = '100px',
}: UseIntersectionObserverProps) {
  const targetRef = useRef<HTMLDivElement>(null);

  const handleIntersect = useCallback(
    (entries: IntersectionObserverEntry[]) => {
      if (entries[0]?.isIntersecting && enabled) {
        onIntersect();
      }
    },
    [onIntersect, enabled]
  );

  useEffect(() => {
    const target = targetRef.current;
    if (!target || !enabled) return;

    const observer = new IntersectionObserver(handleIntersect, {
      threshold,
      rootMargin,
    });

    observer.observe(target);
    return () => observer.disconnect();
  }, [handleIntersect, threshold, rootMargin, enabled]);

  return targetRef;
}
```

The rootMargin of '100px' preloads the next page when user is 100px away from the bottom.
  </action>
  <verify>TypeScript compiles with `npx tsc --noEmit`</verify>
  <done>useIntersectionObserver hook created with proper cleanup</done>
</task>

<task type="auto">
  <name>Task 2: Create InfiniteScrollSentinel and ListStatus components</name>
  <files>src/components/pagination/InfiniteScrollSentinel.tsx, src/components/pagination/ListStatus.tsx</files>
  <action>
**src/components/pagination/InfiniteScrollSentinel.tsx:**

```typescript
import { useIntersectionObserver } from '@/hooks/useIntersectionObserver';

interface InfiniteScrollSentinelProps {
  onLoadMore: () => void;
  hasMore: boolean;
  isLoading: boolean;
}

/**
 * Invisible sentinel element that triggers pagination when scrolled into view.
 * Place at the bottom of a scrollable list.
 */
export function InfiniteScrollSentinel({
  onLoadMore,
  hasMore,
  isLoading,
}: InfiniteScrollSentinelProps) {
  const sentinelRef = useIntersectionObserver({
    onIntersect: onLoadMore,
    enabled: hasMore && !isLoading,
  });

  // 1px height so it's nearly invisible but still observable
  return <div ref={sentinelRef} className="h-px" aria-hidden="true" />;
}
```

**src/components/pagination/ListStatus.tsx:**

```typescript
import { Loader2 } from 'lucide-react';
import { Button } from '@/components/ui/button';

interface ListStatusProps {
  isLoading: boolean;
  hasMore: boolean;
  itemCount: number;
  error?: Error | null;
  onRetry?: () => void;
}

/**
 * Displays loading spinner, end of list message, or error state.
 * Shows "That's everything" when all items loaded (per CONTEXT.md).
 */
export function ListStatus({
  isLoading,
  hasMore,
  itemCount,
  error,
  onRetry,
}: ListStatusProps) {
  // Loading state
  if (isLoading) {
    return (
      <div className="flex justify-center py-6">
        <Loader2 className="w-6 h-6 animate-spin text-muted-foreground" />
      </div>
    );
  }

  // Error state with retry
  if (error && onRetry) {
    return (
      <div className="flex flex-col items-center py-6 gap-2">
        <p className="text-sm text-destructive">Failed to load. Please try again.</p>
        <Button variant="outline" size="sm" onClick={onRetry}>
          Retry
        </Button>
      </div>
    );
  }

  // End of list (only show if there are items)
  if (!hasMore && itemCount > 0) {
    return (
      <div className="flex items-center justify-center py-6 gap-4">
        <div className="h-px flex-1 bg-border" />
        <p className="text-sm text-muted-foreground">That's everything</p>
        <div className="h-px flex-1 bg-border" />
      </div>
    );
  }

  return null;
}
```

These components follow the styling decisions from CONTEXT.md:
- Loading: spinner at bottom of list
- End state: "That's everything" with subtle horizontal dividers
- Error: inline retry button
  </action>
  <verify>TypeScript compiles with `npx tsc --noEmit`</verify>
  <done>InfiniteScrollSentinel triggers onLoadMore when visible; ListStatus shows appropriate state</done>
</task>

<task type="auto">
  <name>Task 3: Create PageSizeSelector component</name>
  <files>src/components/pagination/PageSizeSelector.tsx</files>
  <action>
Create a dropdown for selecting page size:

```typescript
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';

interface PageSizeSelectorProps {
  value: number;
  onChange: (size: number) => void;
  totalCount?: number;
  loadedCount?: number;
}

const PAGE_SIZE_OPTIONS = [10, 25, 50] as const;

/**
 * Dropdown for selecting page size with "Showing X of Y" counter.
 * Default sizes: 10, 25, 50 (per CONTEXT.md).
 */
export function PageSizeSelector({
  value,
  onChange,
  totalCount,
  loadedCount,
}: PageSizeSelectorProps) {
  return (
    <div className="flex items-center justify-between gap-4">
      <div className="flex items-center gap-2">
        <span className="text-sm text-muted-foreground">Show</span>
        <Select
          value={String(value)}
          onValueChange={(val) => onChange(Number(val))}
        >
          <SelectTrigger className="w-[70px] h-8">
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            {PAGE_SIZE_OPTIONS.map((size) => (
              <SelectItem key={size} value={String(size)}>
                {size}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      {totalCount !== undefined && loadedCount !== undefined && (
        <span className="text-sm text-muted-foreground">
          Showing {loadedCount} of {totalCount}
        </span>
      )}
    </div>
  );
}
```

From CONTEXT.md:
- Page size selector at top of list
- Default: 25, Options: 10/25/50
- Show total count: "Showing 25 of 142"
  </action>
  <verify>TypeScript compiles with `npx tsc --noEmit`</verify>
  <done>PageSizeSelector renders dropdown with 10/25/50 options and shows count</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - TypeScript compiles without errors
2. All four files exist in correct locations
3. Components use existing UI primitives (Select, Button)
</verification>

<success_criteria>
- useIntersectionObserver hook observes element visibility with cleanup
- InfiniteScrollSentinel triggers callback only when enabled and not loading
- ListStatus shows loading spinner, "That's everything", or error with retry
- PageSizeSelector renders dropdown with 10/25/50 options and count display
- All files compile without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/13-pagination/13-02-SUMMARY.md`
</output>
