---
phase: 14-render-optimization
plan: 03
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - src/pages/CoachCalendar.tsx
autonomous: true

must_haves:
  truths:
    - "CoachCalendar sub-components only re-render when their specific props change"
    - "DayCell component is wrapped in React.memo"
    - "Event handlers use useCallback for stable references"
    - "Derived data (tasksByDate) uses useMemo for caching"
  artifacts:
    - path: "src/pages/CoachCalendar.tsx"
      provides: "Memoized calendar with optimized sub-components"
      contains: "React.memo"
  key_links:
    - from: "handleDateClick useCallback"
      to: "DayCell React.memo"
      via: "stable prop reference"
      pattern: "useCallback.*handleDateClick"
---

<objective>
Apply selective memoization to CoachCalendar to prevent unnecessary re-renders.

Purpose: CoachCalendar is a known optimization target (per CONTEXT.md) - it re-renders excessively when parent state changes. Applying React.memo to sub-components and memoizing callbacks will reduce render overhead.
Output: Memoized sub-components (WeekView, DayView, TaskList), useCallback for event handlers, useMemo for derived data.
</objective>

<execution_context>
@/Users/haokunyang/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haokunyang/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-render-optimization/14-RESEARCH.md
@.planning/phases/14-render-optimization/14-CONTEXT.md

# Component to optimize
@src/pages/CoachCalendar.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Memoize callbacks in CoachCalendar parent component</name>
  <files>src/pages/CoachCalendar.tsx</files>
  <action>
In the main CoachCalendar component, add useCallback for event handlers:

1. Import useMemo and useCallback from React (add to existing import)

2. Wrap `navigatePeriod` with useCallback:
   ```typescript
   const navigatePeriod = useCallback((direction: number) => {
     if (viewMode === "month") {
       setCurrentDate(new Date(currentDate.getFullYear(), currentDate.getMonth() + direction, 1));
     } else if (viewMode === "week") {
       setCurrentDate(direction > 0 ? addWeeks(currentDate, 1) : subWeeks(currentDate, 1));
     } else {
       setCurrentDate(addDays(currentDate, direction));
     }
   }, [viewMode, currentDate]);
   ```

3. Wrap `goToToday` with useCallback:
   ```typescript
   const goToToday = useCallback(() => {
     setCurrentDate(new Date());
     setSelectedDate(new Date());
   }, []);
   ```

4. Wrap `handleDateClick` with useCallback:
   ```typescript
   const handleDateClick = useCallback((date: Date) => {
     setSelectedDate(date);
     setSheetOpen(true);
   }, []);
   ```

5. Wrap `hasEvents` with useCallback:
   ```typescript
   const hasEvents = useCallback((date: Date) => {
     return getTasksForDate(date).length > 0;
   }, [tasks]); // tasks is used by getTasksForDate
   ```

6. Memoize `getTasksForDate` result as a Map for efficient lookups:
   ```typescript
   const tasksByDateMap = useMemo(() => {
     const map = new Map<string, ScheduledTask[]>();
     tasks.forEach(task => {
       const key = task.scheduledDate;
       const existing = map.get(key) || [];
       map.set(key, [...existing, task]);
     });
     return map;
   }, [tasks]);

   // Update getTasksForDate to use the map
   const getTasksForDate = useCallback((date: Date) => {
     const dateKey = format(date, "yyyy-MM-dd");
     return tasksByDateMap.get(dateKey) || [];
   }, [tasksByDateMap]);
   ```

7. Memoize `getCompletionStats` and `getGroupColorsForDate` with useCallback:
   ```typescript
   const getCompletionStats = useCallback((date: Date) => {
     const dateTasks = getTasksForDate(date);
     const completed = dateTasks.filter((t) => t.status === "completed").length;
     const total = dateTasks.length;
     return { completed, total };
   }, [getTasksForDate]);

   const getGroupColorsForDate = useCallback((date: Date) => {
     const dateTasks = getTasksForDate(date);
     const uniqueColors = [...new Set(dateTasks.map((t) => t.groupColor))];
     return uniqueColors.slice(0, 3);
   }, [getTasksForDate]);
   ```
  </action>
  <verify>
- `npm run build` passes without TypeScript errors
- All useCallback and useMemo are properly imported
- Dependencies arrays are correct (no missing dependencies warnings from ESLint)
  </verify>
  <done>
- navigatePeriod, goToToday, handleDateClick wrapped in useCallback
- tasksByDateMap uses useMemo for efficient task lookup
- getTasksForDate, getCompletionStats, getGroupColorsForDate use useCallback
  </done>
</task>

<task type="auto">
  <name>Task 2: Apply React.memo to sub-components</name>
  <files>src/pages/CoachCalendar.tsx</files>
  <action>
Wrap the sub-components with React.memo:

1. Wrap WeekView with React.memo:
   ```typescript
   const WeekView = React.memo(function WeekView({
     days,
     selectedDate,
     onSelectDate,
     getTasksForDate,
   }: {
     days: Date[];
     selectedDate: Date;
     onSelectDate: (date: Date) => void;
     getTasksForDate: (date: Date) => ScheduledTask[];
   }) {
     // ... existing implementation
   });
   ```

2. Wrap DayView with React.memo:
   ```typescript
   const DayView = React.memo(function DayView({
     date,
     tasks,
     onRefresh,
     userId,
     polishingDescription,
     setPolishingDescription,
     refineTask,
   }: {
     // ... existing props types
   }) {
     // ... existing implementation
   });
   ```

3. Wrap TaskList with React.memo:
   ```typescript
   const TaskList = React.memo(function TaskList({
     tasks,
     onRefresh,
     showDetails = false,
     userId,
     polishingDescription,
     setPolishingDescription,
     refineTask,
   }: {
     // ... existing props types
   }) {
     // ... existing implementation
   });
   ```

4. Wrap DaySheetContent with React.memo:
   ```typescript
   const DaySheetContent = React.memo(function DaySheetContent({
     tasks,
     groups,
     groupMap,
     userId,
     onRefresh,
     polishingDescription,
     setPolishingDescription,
     refineTask,
   }: {
     // ... existing props types
   }) {
     // ... existing implementation
   });
   ```

5. For the month view inline rendering (the grid of day buttons), extract a DayCell component and memoize it:
   ```typescript
   interface DayCellProps {
     date: Date | null;
     isToday: boolean;
     isSelected: boolean;
     stats: { completed: number; total: number };
     groupColors: string[];
     hasEvents: boolean;
     onDateClick: (date: Date) => void;
   }

   const DayCell = React.memo(function DayCell({
     date,
     isToday,
     isSelected,
     stats,
     groupColors,
     hasEvents,
     onDateClick,
   }: DayCellProps) {
     if (!date) {
       return <button disabled className="aspect-square p-1 rounded-lg text-sm font-medium invisible" />;
     }

     return (
       <button
         onClick={() => onDateClick(date)}
         className={cn(
           "aspect-square p-1 rounded-lg text-sm font-medium transition-all relative",
           "hover:bg-muted",
           isToday && "bg-cta-primary/10 text-cta-primary",
           isSelected && "bg-cta-primary text-white",
           !isToday && !isSelected && "text-foreground"
         )}
       >
         {date.getDate()}
         {hasEvents && !isSelected && (
           <div className="absolute bottom-1 left-1/2 -translate-x-1/2 flex gap-0.5">
             {groupColors.map((color, idx) => (
               <span
                 key={idx}
                 className="w-1.5 h-1.5 rounded-full"
                 style={{ backgroundColor: color }}
               />
             ))}
           </div>
         )}
       </button>
     );
   });
   ```

6. Update the month view grid to use DayCell:
   Replace the inline button rendering in the month view with:
   ```tsx
   {(days as (Date | null)[]).map((date, i) => {
     const todayCheck = date ? isToday(date) : false;
     const selectedCheck = date ? isSameDay(date, selectedDate) : false;
     const stats = date ? getCompletionStats(date) : { completed: 0, total: 0 };
     const colors = date ? getGroupColorsForDate(date) : [];
     const hasEventsCheck = date ? hasEvents(date) : false;

     return (
       <DayCell
         key={i}
         date={date}
         isToday={todayCheck}
         isSelected={selectedCheck}
         stats={stats}
         groupColors={colors}
         hasEvents={hasEventsCheck}
         onDateClick={handleDateClick}
       />
     );
   })}
   ```
  </action>
  <verify>
- `npm run build` passes without TypeScript errors
- grep "React.memo" src/pages/CoachCalendar.tsx shows multiple matches
- All sub-components (WeekView, DayView, TaskList, DaySheetContent, DayCell) are wrapped
  </verify>
  <done>
- WeekView, DayView, TaskList, DaySheetContent wrapped in React.memo
- New DayCell component extracted and memoized for month view
- All memoized components receive stable prop references from useCallback/useMemo
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify memoization and test</name>
  <files>src/pages/CoachCalendar.tsx</files>
  <action>
1. Verify all imports are correct at the top of the file:
   - `useState, useEffect, useMemo, useCallback` from 'react'
   - React should be available for React.memo (either default import or named)

2. Ensure the component tree passes stable references:
   - handleDateClick (useCallback) -> DayCell, WeekView
   - getTasksForDate (useCallback) -> WeekView, parent computations
   - onRefresh (from fetchTasks) -> DayView, TaskList, DaySheetContent

3. Add a brief comment at the top of CoachCalendar explaining the optimization:
   ```typescript
   /**
    * CoachCalendar - Coach's calendar view for scheduled tasks.
    *
    * Performance optimizations (Phase 14):
    * - Sub-components (DayCell, WeekView, DayView, TaskList, DaySheetContent) wrapped in React.memo
    * - Event handlers (handleDateClick, navigatePeriod, goToToday) use useCallback
    * - Derived data (tasksByDateMap) uses useMemo
    * - See PROFILING-REPORT.md for baseline measurements
    */
   ```

4. Run tests to ensure no regressions:
   - `npm test` should pass all 240 tests
   - `npm run build` should complete without errors
  </action>
  <verify>
- `npm run build` passes without errors
- `npm test` passes all 240 tests
- Comment at top of CoachCalendar.tsx documents optimization
- All React.memo, useCallback, useMemo patterns are correctly applied
  </verify>
  <done>
- All optimizations verified and documented
- Tests pass confirming no behavioral regressions
- CoachCalendar re-renders only when relevant data changes
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build verification: `npm run build` completes without errors
2. Test verification: `npm test` - all 240 tests pass
3. Memoization verification:
   - grep "React.memo" src/pages/CoachCalendar.tsx returns 5+ matches
   - grep "useCallback" src/pages/CoachCalendar.tsx returns 5+ matches
   - grep "useMemo" src/pages/CoachCalendar.tsx returns 1+ matches
4. Documentation verification:
   - Top of CoachCalendar.tsx has performance optimization comment
</verification>

<success_criteria>
- CoachCalendar parent uses useCallback for all event handlers
- tasksByDateMap uses useMemo for efficient lookups
- DayCell, WeekView, DayView, TaskList, DaySheetContent wrapped in React.memo
- All 240 tests pass (no behavioral regressions)
- Build completes without errors
- Component comment documents optimization strategy
</success_criteria>

<output>
After completion, create `.planning/phases/14-render-optimization/14-03-SUMMARY.md`
</output>
