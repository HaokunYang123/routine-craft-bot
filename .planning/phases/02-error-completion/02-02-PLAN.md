---
phase: 02-error-completion
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/auth/SessionExpiredModal.tsx
  - src/hooks/useAuth.tsx
  - src/App.tsx
autonomous: true

must_haves:
  truths:
    - "JWT expiry shows explicit 'Session expired' message with re-login prompt"
    - "Token refresh is attempted silently in background first; modal only shows if refresh fails"
    - "User stays on current page after re-login (can retry their action)"
    - "Session expiry modal is non-dismissible (must complete re-login to close)"
  artifacts:
    - path: "src/components/auth/SessionExpiredModal.tsx"
      provides: "Non-dismissible modal for session expiry"
      exports: ["SessionExpiredModal"]
    - path: "src/hooks/useAuth.tsx"
      provides: "Auth hook with session expiry detection"
      exports: ["useAuth"]
  key_links:
    - from: "src/hooks/useAuth.tsx"
      to: "supabase.auth.onAuthStateChange"
      via: "SIGNED_OUT event listener"
      pattern: "onAuthStateChange.*SIGNED_OUT"
    - from: "src/App.tsx"
      to: "src/components/auth/SessionExpiredModal.tsx"
      via: "renders modal at app root"
      pattern: "SessionExpiredModal"
---

<objective>
Implement JWT session expiry detection with explicit user messaging.

Purpose: When Supabase's silent token refresh fails, show a clear modal explaining session expiry and prompting re-login. This addresses ERR-04 requirement for graceful JWT error handling with explicit messaging.

Output: SessionExpiredModal component and updated useAuth hook that detects session expiry via Supabase auth events.
</objective>

<execution_context>
@/Users/haokunyang/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haokunyang/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-error-completion/02-CONTEXT.md
@.planning/phases/02-error-completion/02-RESEARCH.md

Reference existing patterns:
@src/hooks/useAuth.tsx
@src/components/ui/alert-dialog.tsx
@src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SessionExpiredModal component</name>
  <files>src/components/auth/SessionExpiredModal.tsx</files>
  <action>
Create a non-dismissible AlertDialog modal for session expiry.

Implementation requirements:
1. Props interface:
   ```typescript
   interface SessionExpiredModalProps {
     open: boolean;
     onReLogin: () => void;
   }
   ```

2. Use AlertDialog from @/components/ui/alert-dialog
3. Make modal non-dismissible:
   - Add `onEscapeKeyDown={(e) => e.preventDefault()}` to AlertDialogContent
   - Add `onPointerDownOutside={(e) => e.preventDefault()}` to AlertDialogContent
   - Do NOT include AlertDialogCancel - only the action button

4. Content:
   - Title: "Session Expired"
   - Description: "Your session has expired. Please sign in again to continue where you left off."
   - Single action button: "Sign In Again" (triggers onReLogin)

5. Styling: Use default AlertDialog styling from shadcn/ui

Import from:
- AlertDialog, AlertDialogContent, AlertDialogHeader, AlertDialogTitle, AlertDialogDescription, AlertDialogFooter, AlertDialogAction from @/components/ui/alert-dialog
  </action>
  <verify>
- File exists at src/components/auth/SessionExpiredModal.tsx
- TypeScript compiles: `npx tsc --noEmit`
- Component exports SessionExpiredModal
  </verify>
  <done>
SessionExpiredModal component created with non-dismissible behavior (escape/click-outside prevented).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add session expiry detection to useAuth</name>
  <files>src/hooks/useAuth.tsx</files>
  <action>
Extend useAuth hook to detect session expiry via Supabase auth events and provide state for the modal.

Implementation requirements:
1. Add new state:
   ```typescript
   const [sessionExpired, setSessionExpired] = useState(false);
   ```

2. Update onAuthStateChange listener to detect unexpected session loss:
   ```typescript
   if (event === 'SIGNED_OUT') {
     // Only show modal if this wasn't an explicit signout
     // (explicit signout navigates to /, so sessionExpired won't matter)
     setSessionExpired(true);
   } else if (event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') {
     // Clear expiry state on successful refresh or sign-in
     setSessionExpired(false);
   }
   ```

3. Add clearSessionExpired function for after re-login:
   ```typescript
   const clearSessionExpired = () => setSessionExpired(false);
   ```

4. Update return value to include:
   - sessionExpired: boolean
   - clearSessionExpired: () => void

5. Keep existing signOut function but ensure it navigates BEFORE setSessionExpired could show modal

Note: Supabase handles silent token refresh automatically via autoRefreshToken. The SIGNED_OUT event fires when refresh fails (e.g., refresh token expired after 7+ days of inactivity).
  </action>
  <verify>
- useAuth now returns sessionExpired and clearSessionExpired
- TypeScript compiles: `npx tsc --noEmit`
- Existing signOut behavior preserved
  </verify>
  <done>
useAuth hook extended with sessionExpired state that detects SIGNED_OUT events from Supabase auth.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire SessionExpiredModal in App.tsx</name>
  <files>src/App.tsx</files>
  <action>
Add SessionExpiredModal to App.tsx and wire it to useAuth's session expiry state.

Implementation requirements:
1. Import SessionExpiredModal from @/components/auth/SessionExpiredModal

2. Create a small wrapper component inside App.tsx (or extract if preferred) that:
   - Uses useAuth() to get sessionExpired and clearSessionExpired
   - Renders SessionExpiredModal with:
     - open={sessionExpired}
     - onReLogin handler that:
       a. Calls clearSessionExpired()
       b. Navigates to /login (or appropriate auth page)

3. Place the wrapper inside the existing Router context but outside route definitions:
   ```tsx
   <BrowserRouter>
     <AppErrorBoundary>
       <SessionExpiredHandler />  {/* NEW */}
       <Routes>
         ...
       </Routes>
     </AppErrorBoundary>
   </BrowserRouter>
   ```

4. Alternative approach if useAuth needs Router context:
   - Create SessionExpiredHandler as separate component
   - Use useNavigate inside it for re-login navigation

Important: The modal should NOT appear on the login page itself. Add a check:
```typescript
const location = useLocation();
const isAuthPage = location.pathname.startsWith('/login') || location.pathname === '/';
// Only show modal if not already on auth page
<SessionExpiredModal open={sessionExpired && !isAuthPage} ... />
```
  </action>
  <verify>
- App.tsx imports and renders SessionExpiredModal
- Build succeeds: `npm run build`
- No visible changes when session is valid (modal hidden)
  </verify>
  <done>
SessionExpiredModal wired in App.tsx, showing on session expiry and navigating to login on re-login action.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run `npx tsc --noEmit` - no TypeScript errors
2. Run `npm run build` - build succeeds
3. Manual verification (if running locally):
   - Session expiry modal should NOT appear during normal usage
   - Modal should be non-dismissible (escape and click-outside do nothing)
</verification>

<success_criteria>
- SessionExpiredModal is non-dismissible (must click "Sign In Again")
- useAuth detects SIGNED_OUT event and sets sessionExpired state
- Modal appears at app root level (works on any page)
- Modal does not appear on auth pages
- Re-login navigates to login page and clears expiry state
</success_criteria>

<output>
After completion, create `.planning/phases/02-error-completion/02-02-SUMMARY.md`
</output>
