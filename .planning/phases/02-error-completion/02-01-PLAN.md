---
phase: 02-error-completion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/ui/loading-button.tsx
  - src/components/ui/skeleton.tsx
  - src/components/skeletons/DashboardSkeleton.tsx
  - src/components/skeletons/TaskListSkeleton.tsx
autonomous: true

must_haves:
  truths:
    - "Buttons show spinner icon during async operations while text remains visible"
    - "Data fetching displays skeleton placeholders that mimic content layout"
    - "Submit buttons are disabled during form submission but form inputs remain editable"
  artifacts:
    - path: "src/components/ui/loading-button.tsx"
      provides: "LoadingButton component with integrated isLoading prop"
      exports: ["LoadingButton"]
    - path: "src/components/skeletons/DashboardSkeleton.tsx"
      provides: "Skeleton placeholder for dashboard stats cards"
      exports: ["DashboardSkeleton", "StatsCardSkeleton"]
    - path: "src/components/skeletons/TaskListSkeleton.tsx"
      provides: "Skeleton placeholder for task list items"
      exports: ["TaskListSkeleton", "TaskItemSkeleton"]
  key_links:
    - from: "src/components/ui/loading-button.tsx"
      to: "src/components/ui/button.tsx"
      via: "extends Button with isLoading prop"
      pattern: "import.*Button.*from.*button"
    - from: "src/components/skeletons/DashboardSkeleton.tsx"
      to: "src/components/ui/skeleton.tsx"
      via: "uses Skeleton for placeholder elements"
      pattern: "import.*Skeleton.*from.*skeleton"
---

<objective>
Create reusable loading state components for async operations.

Purpose: Provide consistent visual feedback during async operations - spinner icons for buttons, skeleton placeholders for data fetching. This addresses ERR-03 requirement for loading states on all async operations.

Output: LoadingButton component and skeleton placeholder components ready for adoption across the app.
</objective>

<execution_context>
@/Users/haokunyang/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haokunyang/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-error-completion/02-CONTEXT.md
@.planning/phases/02-error-completion/02-RESEARCH.md

Reference existing patterns:
@src/components/ui/button.tsx
@src/components/ui/skeleton.tsx
@src/components/auth/CoachAuth.tsx (lines 147-149, 190-193 for loading button pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create LoadingButton component</name>
  <files>src/components/ui/loading-button.tsx</files>
  <action>
Create a LoadingButton component that wraps the existing Button component with integrated loading state support.

Implementation requirements:
1. Accept all standard Button props plus `isLoading?: boolean`
2. When isLoading is true:
   - Show Loader2 icon with animate-spin class before children
   - Add disabled state (via disabled || isLoading)
   - Keep button text visible (not replaced by spinner)
3. Use exact pattern from CoachAuth.tsx lines 190-193:
   ```tsx
   {isLoading && <Loader2 className="w-4 h-4 mr-2 animate-spin" />}
   {children}
   ```
4. Forward ref properly using React.forwardRef
5. Export both LoadingButton and LoadingButtonProps

Import from:
- Loader2 from lucide-react
- Button, ButtonProps from @/components/ui/button
- React from react
  </action>
  <verify>
- File exists at src/components/ui/loading-button.tsx
- TypeScript compiles without errors: `npx tsc --noEmit`
- Exports LoadingButton component
  </verify>
  <done>
LoadingButton component created with isLoading prop that shows spinner while keeping text visible.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create skeleton placeholder components</name>
  <files>
src/components/skeletons/DashboardSkeleton.tsx
src/components/skeletons/TaskListSkeleton.tsx
  </files>
  <action>
Create skeleton placeholder components for the two primary data loading scenarios.

**DashboardSkeleton.tsx:**
1. Create StatsCardSkeleton - single card skeleton matching dashboard stats cards:
   - Card container with same styling as existing cards (bg-card shadow-card border-0 rounded-2xl)
   - Skeleton for title (h-4 w-24)
   - Skeleton for icon area (h-8 w-8 rounded-full)
   - Skeleton for value (h-8 w-12)
   - Skeleton for subtitle (h-3 w-28)
2. Create DashboardSkeleton - grid of 4 StatsCardSkeletons:
   - Same grid layout as dashboard (grid gap-4 md:grid-cols-2 lg:grid-cols-4)
3. Export both components

**TaskListSkeleton.tsx:**
1. Create TaskItemSkeleton - single task item skeleton:
   - Flex container with checkbox placeholder (h-5 w-5 rounded)
   - Task title skeleton (h-4 w-48)
   - Task meta skeleton (h-3 w-24)
2. Create TaskListSkeleton - list of 5 TaskItemSkeletons:
   - Space-y-3 container
   - Each item has subtle border-b
3. Export both components

Import from:
- Skeleton from @/components/ui/skeleton
- Card, CardHeader, CardContent from @/components/ui/card (for DashboardSkeleton)
  </action>
  <verify>
- Both files exist in src/components/skeletons/
- TypeScript compiles without errors: `npx tsc --noEmit`
- Each file exports both individual and grouped skeleton components
  </verify>
  <done>
Skeleton components created for dashboard stats and task lists, matching existing UI layout patterns.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run `npx tsc --noEmit` - no TypeScript errors
2. Run `npm run build` - build succeeds
3. Verify exports:
   - LoadingButton from src/components/ui/loading-button.tsx
   - DashboardSkeleton, StatsCardSkeleton from src/components/skeletons/DashboardSkeleton.tsx
   - TaskListSkeleton, TaskItemSkeleton from src/components/skeletons/TaskListSkeleton.tsx
</verification>

<success_criteria>
- LoadingButton component accepts isLoading prop and shows spinner with text
- Skeleton components match existing card/list layouts in the app
- All new files compile and build without errors
- Components are ready for adoption in existing code (no adoption in this plan)
</success_criteria>

<output>
After completion, create `.planning/phases/02-error-completion/02-01-SUMMARY.md`
</output>
