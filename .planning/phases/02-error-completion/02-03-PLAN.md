---
phase: 02-error-completion
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useAIAssistant.ts
  - src/components/FloatingAI.tsx
  - src/components/ai/AIPlanBuilder.tsx
autonomous: true

must_haves:
  truths:
    - "AI assistant retries failed requests 3 times with exponential backoff before showing error"
    - "Retry attempts are silent (user sees loading indicator, doesn't know about retries)"
    - "Timeout errors show 'Request timed out. Try asking for less information at once.'"
    - "User can cancel AI request while waiting (cancel button shown during loading)"
  artifacts:
    - path: "src/hooks/useAIAssistant.ts"
      provides: "AI assistant hook with retry logic and cancellation support"
      exports: ["useAIAssistant"]
  key_links:
    - from: "src/hooks/useAIAssistant.ts"
      to: "AbortController"
      via: "cancellation support for pending requests"
      pattern: "AbortController|signal\\.aborted"
    - from: "src/components/FloatingAI.tsx"
      to: "cancel function from useAIAssistant"
      via: "cancel button in loading state"
      pattern: "cancel|onCancel"
---

<objective>
Implement retry logic with exponential backoff for AI assistant requests.

Purpose: Improve AI assistant reliability by automatically retrying transient failures (timeouts, 5xx errors) with exponential backoff (1s, 2s, 4s delays). Users see a loading indicator during retries and can cancel if waiting too long. This addresses ERR-05 requirement for AI retry logic.

Output: Updated useAIAssistant hook with retry logic and cancel support, plus cancel buttons in AI UI components.
</objective>

<execution_context>
@/Users/haokunyang/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haokunyang/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-error-completion/02-CONTEXT.md
@.planning/phases/02-error-completion/02-RESEARCH.md

Reference existing code:
@src/hooks/useAIAssistant.ts
@src/components/FloatingAI.tsx
@src/components/ai/AIPlanBuilder.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add retry logic to useAIAssistant hook</name>
  <files>src/hooks/useAIAssistant.ts</files>
  <action>
Modify useAIAssistant to add exponential backoff retry logic for transient failures.

Implementation requirements:

1. Add AbortController state for cancellation:
   ```typescript
   const abortControllerRef = useRef<AbortController | null>(null);
   ```

2. Create cancel function:
   ```typescript
   const cancel = useCallback(() => {
     abortControllerRef.current?.abort();
     abortControllerRef.current = null;
     setLoading(false);
   }, []);
   ```

3. Modify callAIAssistant to implement retry logic:
   - Create new AbortController at start of each call
   - Store in abortControllerRef
   - Retry config: maxRetries = 3, delays = [1000, 2000, 4000] (1s, 2s, 4s)
   - Only retry on transient errors (check for these patterns):
     - Timeout errors: 'timeout', 'timed out', 'abort', 'AbortError'
     - Server errors: status 500, 502, 503, 504, 'service error', 'internal'
   - Do NOT retry on:
     - Auth errors (401, 'unauthorized', 'jwt')
     - Rate limits (429)
     - Client errors (4xx)
     - User cancellation (signal.aborted)

4. Retry loop structure:
   ```typescript
   const delays = [1000, 2000, 4000];
   for (let attempt = 0; attempt < 3; attempt++) {
     if (abortControllerRef.current?.signal.aborted) {
       return { success: false, error: 'Request cancelled' };
     }

     try {
       // Make the request
       const result = await makeRequest();
       if (result.success) return result;

       // Check if error is retryable
       if (!isRetryableError(result.error)) return result;

       // Wait before next attempt (unless last attempt)
       if (attempt < 2) {
         await new Promise(resolve => setTimeout(resolve, delays[attempt]));
       }
     } catch (err) {
       // Handle caught errors similarly
     }
   }

   // All retries exhausted - return timeout message
   return {
     success: false,
     error: "Request timed out. Try asking for less information at once."
   };
   ```

5. Helper function for error classification:
   ```typescript
   function isRetryableError(errorMsg: string | undefined): boolean {
     if (!errorMsg) return false;
     const msg = errorMsg.toLowerCase();
     return (
       msg.includes('timeout') ||
       msg.includes('timed out') ||
       msg.includes('service error') ||
       msg.includes('internal') ||
       msg.includes('504') ||
       msg.includes('503') ||
       msg.includes('502')
     );
   }
   ```

6. Update return value to include cancel function:
   ```typescript
   return {
     loading,
     error,
     cancel,  // NEW
     generatePlan,
     personalizePlan,
     // ... other methods
   };
   ```

7. Cleanup on unmount:
   ```typescript
   useEffect(() => {
     return () => {
       abortControllerRef.current?.abort();
     };
   }, []);
   ```

Important: Keep retries SILENT - do not change loading state between retry attempts. User should only see continuous loading indicator.
  </action>
  <verify>
- useAIAssistant exports cancel function
- TypeScript compiles: `npx tsc --noEmit`
- Retry logic only triggers on transient errors
  </verify>
  <done>
useAIAssistant hook updated with 3-retry exponential backoff (1s, 2s, 4s), cancellation support, and specific timeout error message.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add cancel button to FloatingAI</name>
  <files>src/components/FloatingAI.tsx</files>
  <action>
Update FloatingAI to show a cancel button during AI loading state.

Implementation requirements:

1. This component uses direct supabase.functions.invoke, not useAIAssistant. Add local cancellation support:
   ```typescript
   const abortControllerRef = useRef<AbortController | null>(null);

   const handleCancel = () => {
     abortControllerRef.current?.abort();
     abortControllerRef.current = null;
     setIsLoading(false);
   };
   ```

2. Update handleSubmit to create AbortController and implement retry:
   - Follow same retry pattern as useAIAssistant
   - 3 retries with 1s, 2s, 4s delays
   - Only retry on transient errors

3. Add cancel button in the loading state area (near the bouncing dots):
   ```tsx
   {isLoading && (
     <div className="flex items-center gap-2 px-4">
       <span className="w-2 h-2 bg-primary rounded-full animate-bounce" />
       <span className="w-2 h-2 bg-primary rounded-full animate-bounce" style={{ animationDelay: "150ms" }} />
       <span className="w-2 h-2 bg-primary rounded-full animate-bounce" style={{ animationDelay: "300ms" }} />
       <button
         onClick={handleCancel}
         className="ml-2 text-xs text-muted-foreground hover:text-foreground"
       >
         Cancel
       </button>
     </div>
   )}
   ```

4. Cleanup on unmount:
   ```typescript
   useEffect(() => {
     return () => {
       abortControllerRef.current?.abort();
     };
   }, []);
   ```

5. Handle cancelled state gracefully - don't add error message to chat if cancelled.
  </action>
  <verify>
- FloatingAI shows cancel button during loading
- TypeScript compiles: `npx tsc --noEmit`
- Build succeeds: `npm run build`
  </verify>
  <done>
FloatingAI updated with cancel button during loading and retry logic for transient failures.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add cancel button to AIPlanBuilder</name>
  <files>src/components/ai/AIPlanBuilder.tsx</files>
  <action>
Update AIPlanBuilder to use cancel function from useAIAssistant.

Implementation requirements:

1. Destructure cancel from useAIAssistant:
   ```typescript
   const { loading, error, cancel, generatePlan, modifyPlan } = useAIAssistant();
   ```

2. Find the loading indicator in this component (look for where `loading` is used to show spinner/loading state)

3. Add cancel button near the loading indicator. Common patterns:
   - If there's a loading overlay: add cancel button below spinner
   - If loading is shown in a button: add small cancel link nearby
   - Style: subtle text button "Cancel" that calls cancel()

4. Example placement (adjust based on actual component structure):
   ```tsx
   {loading && (
     <div className="flex flex-col items-center gap-2">
       <Loader2 className="w-6 h-6 animate-spin" />
       <button
         onClick={cancel}
         className="text-sm text-muted-foreground hover:text-foreground"
       >
         Cancel
       </button>
     </div>
   )}
   ```

5. If there's form state that needs clearing on cancel, add that logic to the cancel handler.

Note: Read the actual component structure first to determine appropriate cancel button placement.
  </action>
  <verify>
- AIPlanBuilder uses cancel from useAIAssistant
- Cancel button visible during loading state
- TypeScript compiles: `npx tsc --noEmit`
- Build succeeds: `npm run build`
  </verify>
  <done>
AIPlanBuilder updated with cancel button that uses useAIAssistant's cancel function.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run `npx tsc --noEmit` - no TypeScript errors
2. Run `npm run build` - build succeeds
3. Verify cancel function exported from useAIAssistant
4. Manual verification (if running locally):
   - AI request shows loading indicator
   - Cancel button appears during loading
   - Clicking cancel stops the request
</verification>

<success_criteria>
- useAIAssistant retries transient failures 3 times with 1s, 2s, 4s delays
- Retries are silent (loading state unchanged during retry attempts)
- Final timeout error shows "Request timed out. Try asking for less information at once."
- Cancel button appears in FloatingAI and AIPlanBuilder during loading
- Cancel aborts pending request and clears loading state
- No memory leaks (AbortController cleaned up on unmount)
</success_criteria>

<output>
After completion, create `.planning/phases/02-error-completion/02-03-SUMMARY.md`
</output>
