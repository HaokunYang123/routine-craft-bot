---
phase: 07-hook-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useAuth.test.tsx
autonomous: true

must_haves:
  truths:
    - "useAuth starts in loading state"
    - "useAuth sets user when session exists"
    - "useAuth sets user to null when no session"
    - "useAuth sets sessionExpired on SIGNED_OUT event"
    - "useAuth clears sessionExpired on TOKEN_REFRESHED"
    - "signOut navigates to home and signs out"
  artifacts:
    - path: "src/hooks/useAuth.test.tsx"
      provides: "useAuth hook test suite"
      min_lines: 100
      contains: "describe('useAuth'"
  key_links:
    - from: "src/hooks/useAuth.test.tsx"
      to: "src/hooks/useAuth.tsx"
      via: "import { useAuth }"
      pattern: "import.*useAuth.*from"
    - from: "src/hooks/useAuth.test.tsx"
      to: "src/test/mocks/supabase.ts"
      via: "mock imports"
      pattern: "getMockSupabase|resetMockSupabase"
---

<objective>
Comprehensive test coverage for useAuth hook covering all authentication states

Purpose: Verify useAuth correctly manages loading, authenticated, unauthenticated, session expiry, and signOut states. This is the foundation hook that other hooks depend on.

Output: `src/hooks/useAuth.test.tsx` with tests for all auth states and transitions
</objective>

<execution_context>
@/Users/haokunyang/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haokunyang/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-hook-tests/07-RESEARCH.md

@src/hooks/useAuth.tsx
@src/test/mocks/supabase.ts
@src/test/test-utils.tsx
@src/test/setup.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useAuth test file with state tests</name>
  <files>src/hooks/useAuth.test.tsx</files>
  <action>
Create comprehensive test suite for useAuth hook:

1. Test file structure:
   - Import renderHook, waitFor, act from @testing-library/react
   - Import MemoryRouter for wrapper
   - Mock @/integrations/supabase/client using mockSupabaseModule
   - Mock react-router-dom useNavigate to capture navigation calls
   - Create wrapper function with MemoryRouter

2. Capture onAuthStateChange callback:
   - In beforeEach, capture the callback passed to onAuthStateChange
   - Store in `authStateCallback` variable for triggering auth events in tests

3. Test describe blocks:

   describe('loading state'):
   - Test: starts in loading state
   - Mock getSession to never resolve (pending promise)
   - Assert: result.current.loading === true, result.current.user === null

   describe('authenticated state'):
   - Test: sets user when session exists
   - Mock getSession to resolve with valid session (use createMockSession)
   - Assert: loading becomes false, user.id matches mock

   describe('unauthenticated state'):
   - Test: sets user to null when no session
   - Mock getSession to resolve with null session
   - Assert: loading false, user null, session null

   describe('session expiry'):
   - Test: sets sessionExpired on SIGNED_OUT event
   - After initial load, call authStateCallback('SIGNED_OUT', null) in act()
   - Assert: sessionExpired === true
   - Test: clears sessionExpired on TOKEN_REFRESHED event
   - Call authStateCallback('TOKEN_REFRESHED', newSession) in act()
   - Assert: sessionExpired === false

   describe('signOut'):
   - Test: navigates to home and signs out
   - Call result.current.signOut() in act()
   - Assert: mockNavigate called with '/'
   - Assert: getMockSupabase().auth.signOut called

4. Clean up in beforeEach:
   - Call resetMockSupabase()
   - Clear mockNavigate mock
   - Reset authStateCallback to null

Pattern references: See 07-RESEARCH.md "Pattern 2: Mocking Supabase Auth Subscription"
  </action>
  <verify>npm run test -- src/hooks/useAuth.test.tsx --run</verify>
  <done>
    - 6 tests pass covering: loading, authenticated, unauthenticated, session expiry (set/clear), signOut
    - No act() warnings in console
    - All auth state transitions verified
  </done>
</task>

<task type="auto">
  <name>Task 2: Add subscription cleanup test</name>
  <files>src/hooks/useAuth.test.tsx</files>
  <action>
Add test for subscription cleanup on unmount:

1. Add describe('cleanup') block:
   - Test: unsubscribes on unmount
   - Create mock unsubscribe function via getMockSupabase().auth.onAuthStateChange
   - Render hook, then call unmount() from renderHook result
   - Assert: unsubscribe mock was called

2. Test pattern:
```typescript
it('unsubscribes on unmount', async () => {
  const mockUnsubscribe = vi.fn();
  getMockSupabase().auth.onAuthStateChange.mockImplementation((callback) => {
    authStateCallback = callback;
    return { data: { subscription: { unsubscribe: mockUnsubscribe } } };
  });

  const { unmount } = renderHook(() => useAuth(), { wrapper: createWrapper() });

  // Wait for initial load
  await waitFor(() => expect(result.current.loading).toBe(false));

  unmount();

  expect(mockUnsubscribe).toHaveBeenCalled();
});
```

This verifies memory leak prevention from Phase 6 cleanup patterns.
  </action>
  <verify>npm run test -- src/hooks/useAuth.test.tsx --run</verify>
  <done>
    - 7 tests total pass
    - Cleanup test verifies unsubscribe called on unmount
  </done>
</task>

</tasks>

<verification>
- All useAuth tests pass: `npm run test -- src/hooks/useAuth.test.tsx --run`
- No console warnings about missing act() wrappers
- Coverage shows all auth state branches tested
</verification>

<success_criteria>
- HOOK-01 requirement satisfied: useAuth has tests for loading, authenticated, unauthenticated, and error states
- Session persistence tested via TOKEN_REFRESHED/SIGNED_OUT events
- signOut behavior verified (navigate first, then sign out)
- Subscription cleanup tested (unsubscribe on unmount)
</success_criteria>

<output>
After completion, create `.planning/phases/07-hook-tests/07-01-SUMMARY.md`
</output>
