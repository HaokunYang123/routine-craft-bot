---
phase: 01-error-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/error.ts
autonomous: true

must_haves:
  truths:
    - "Errors display user-friendly toast messages with actionable recovery options"
    - "All error events are logged with structured context (component, user action, timestamp)"
    - "Retry action is opt-in per call (developer chooses which operations show retry)"
    - "Technical error details hidden from users (console only)"
  artifacts:
    - path: "src/lib/error.ts"
      provides: "handleError utility with toast + structured logging + optional retry"
      exports: ["handleError", "ErrorContext", "getUserFriendlyMessage"]
  key_links:
    - from: "src/lib/error.ts"
      to: "sonner"
      via: "toast import"
      pattern: "toast\\.error"
    - from: "src/lib/error.ts"
      to: "console.error"
      via: "structured logging"
      pattern: "console\\.error.*ErrorLog"
---

<objective>
Create a centralized error handling utility that standardizes toast notifications and structured logging across the app.

Purpose: Provides a single `handleError` function that hooks can call in catch blocks. This ensures consistent user feedback (friendly toast with optional retry) and consistent logging (structured JSON with context). Eliminates ad-hoc error handling patterns.

Output: `src/lib/error.ts` with handleError utility, TypeScript interfaces, and user-friendly message mapping.
</objective>

<execution_context>
@/Users/haokunyang/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haokunyang/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-error-foundation/01-CONTEXT.md
@.planning/phases/01-error-foundation/01-RESEARCH.md

# Source files to reference
@src/lib/utils.ts
@src/components/ui/sonner.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error handling utility with types</name>
  <files>
    - src/lib/error.ts
  </files>
  <action>
Create `src/lib/error.ts` with the following:

1. **TypeScript interfaces:**

```typescript
export interface ErrorContext {
  component?: string;    // Component name where error occurred
  action?: string;       // User action that triggered error (e.g., "save", "delete", "fetch")
  userId?: string;       // Current user ID if available
  retry?: () => void | Promise<void>;  // Optional retry function
  silent?: boolean;      // If true, log only - no toast shown
}

interface ErrorLogEntry {
  severity: 'error' | 'warning' | 'info';
  timestamp: string;
  message: string;
  stack?: string;
  context: {
    component?: string;
    action?: string;
    userId?: string;
    route: string;
    [key: string]: unknown;
  };
  environment: {
    url: string;
    userAgent: string;
    viewport: { width: number; height: number };
  };
}
```

2. **User-friendly message mapping:**

```typescript
export function getUserFriendlyMessage(errorMessage: string): string {
  // Map technical errors to user-friendly messages
  const mappings: Array<{ pattern: RegExp; message: string }> = [
    { pattern: /network|fetch|ECONNREFUSED/i, message: "Unable to connect. Please check your internet connection." },
    { pattern: /timeout|ETIMEDOUT/i, message: "Request timed out. Please try again." },
    { pattern: /unauthorized|401/i, message: "Your session has expired. Please log in again." },
    { pattern: /forbidden|403/i, message: "You don't have permission to perform this action." },
    { pattern: /not found|404/i, message: "The requested item could not be found." },
    { pattern: /server error|500|502|503/i, message: "Something went wrong on our end. Please try again later." },
    { pattern: /validation|invalid/i, message: "Please check your input and try again." },
  ];

  for (const { pattern, message } of mappings) {
    if (pattern.test(errorMessage)) {
      return message;
    }
  }

  // Default friendly message for unmapped errors
  return "Something went wrong. Please try again.";
}
```

3. **Structured logging function:**

```typescript
function logError(
  error: unknown,
  context: ErrorContext = {},
  severity: ErrorLogEntry['severity'] = 'error'
): void {
  const entry: ErrorLogEntry = {
    severity,
    timestamp: new Date().toISOString(),
    message: error instanceof Error ? error.message : String(error),
    stack: error instanceof Error ? error.stack : undefined,
    context: {
      component: context.component,
      action: context.action,
      userId: context.userId,
      route: window.location.pathname,
    },
    environment: {
      url: window.location.href,
      userAgent: navigator.userAgent,
      viewport: {
        width: window.innerWidth,
        height: window.innerHeight,
      },
    },
  };

  // Structured console output - easy to filter in DevTools
  console.error('[App Error]', entry);
}
```

4. **Main handleError function:**

```typescript
import { toast } from 'sonner';

export function handleError(error: unknown, context: ErrorContext = {}): void {
  // 1. Extract error message safely
  const errorMessage = error instanceof Error ? error.message : String(error);

  // 2. Always log with structure (never skip logging)
  try {
    logError(error, context);
  } catch {
    // Logging should never crash the app
    console.error('[Logging Failed]', errorMessage);
  }

  // 3. Show toast unless silent mode
  if (!context.silent) {
    const friendlyMessage = getUserFriendlyMessage(errorMessage);

    // Build toast options
    const toastOptions: Parameters<typeof toast.error>[1] = {};

    // Add retry action if provided (opt-in per user decision)
    if (context.retry) {
      toastOptions.action = {
        label: 'Retry',
        onClick: () => {
          // Wrap retry in try/catch to prevent unhandled promise rejections
          try {
            const result = context.retry?.();
            if (result instanceof Promise) {
              result.catch((retryError) => {
                handleError(retryError, { ...context, retry: undefined }); // Prevent infinite retry loops
              });
            }
          } catch (retryError) {
            handleError(retryError, { ...context, retry: undefined });
          }
        },
      };
    }

    toast.error(friendlyMessage, toastOptions);
  }
}
```

5. **Export all public API:**
```typescript
export { handleError, getUserFriendlyMessage };
export type { ErrorContext };
```

Key implementation details:
- Toast uses Sonner (already configured in Plan 01)
- Retry is opt-in: only shows button if `retry` function provided in context
- Silent mode for background operations that shouldn't show toast
- Prevents retry from creating infinite error loops
- Logging never throws (wrapped in try/catch)
- Technical details only in console (per user decision)
  </action>
  <verify>
    - `ls src/lib/error.ts` confirms file exists
    - `npm run build` succeeds with no TypeScript errors
    - File exports handleError, getUserFriendlyMessage, and ErrorContext type
  </verify>
  <done>
    - src/lib/error.ts created with full implementation
    - handleError function logs structured errors and shows user-friendly toast
    - getUserFriendlyMessage maps technical errors to friendly messages
    - Retry action is opt-in via context.retry parameter
    - Silent mode available via context.silent for background operations
  </done>
</task>

<task type="auto">
  <name>Task 2: Validate error utility integration</name>
  <files>
    - (no files modified - validation only)
  </files>
  <action>
Validate the error utility works correctly by testing in isolation:

1. Create a temporary test in the browser console or a scratch component:
```typescript
import { handleError, getUserFriendlyMessage } from '@/lib/error';

// Test 1: Basic error with toast
handleError(new Error('Test error'), { component: 'TestComponent', action: 'test' });
// Expected: Toast appears with "Something went wrong. Please try again."
// Expected: Console shows structured log with component, action, timestamp, etc.

// Test 2: Network error mapping
console.log(getUserFriendlyMessage('Network request failed'));
// Expected: "Unable to connect. Please check your internet connection."

// Test 3: Silent mode (no toast)
handleError(new Error('Background error'), { silent: true });
// Expected: Console log only, no toast

// Test 4: With retry
handleError(new Error('Save failed'), {
  action: 'save',
  retry: () => console.log('Retry clicked!')
});
// Expected: Toast with "Retry" button, clicking logs "Retry clicked!"
```

2. Verify structured log output in DevTools:
   - Open DevTools Console
   - Filter by "[App Error]"
   - Confirm log entry has: severity, timestamp, message, context (component, action, route), environment (url, userAgent, viewport)

3. Verify error message mappings cover common cases:
   - Network errors -> connection message
   - Timeout -> timeout message
   - 401/unauthorized -> session expired message
   - 403/forbidden -> permission message
   - 404 -> not found message
   - 500+ -> server error message
   - Unknown -> generic "Something went wrong" message
  </action>
  <verify>
    - Manual testing in browser confirms toast appears with friendly message
    - Console shows structured JSON log entry
    - Retry button appears only when retry function provided
    - Silent mode suppresses toast but still logs
  </verify>
  <done>
    - Error utility functions correctly in browser
    - Structured logging includes all required context fields
    - User-friendly messages display instead of technical errors
    - Retry action works when provided
  </done>
</task>

</tasks>

<verification>
After completing both tasks:

1. Build verification:
   ```bash
   npm run build
   ```
   Must succeed with no errors.

2. Type checking:
   ```bash
   npx tsc --noEmit
   ```
   No type errors in src/lib/error.ts

3. Manual integration test:
   - Open app in browser
   - Open DevTools Console
   - In any existing hook/component, temporarily replace a catch block:
   ```typescript
   // Before (example from existing code)
   catch (error) {
     console.error('Error:', error);
   }

   // After (using new utility)
   import { handleError } from '@/lib/error';
   catch (error) {
     handleError(error, { component: 'ComponentName', action: 'actionName' });
   }
   ```
   - Trigger the error condition
   - Verify: Toast appears with friendly message
   - Verify: Console shows structured log with all context

4. Edge case tests:
   - Pass non-Error object: `handleError("string error")`
   - Pass null/undefined in context fields
   - Call retry when it throws
   - All should handle gracefully without crashing
</verification>

<success_criteria>
- handleError utility exists at src/lib/error.ts
- Calling handleError shows user-friendly toast (not technical error message)
- Console logs contain structured JSON with: timestamp, message, stack, context (component, action, userId, route), environment (url, userAgent, viewport)
- Retry button only appears when retry function provided in context
- Silent mode logs but doesn't show toast
- Build passes with no TypeScript errors
- Utility is ready for adoption in existing catch blocks (Phase 2+ work)
</success_criteria>

<output>
After completion, create `.planning/phases/01-error-foundation/01-02-SUMMARY.md` using summary template.
</output>
