---
phase: 01-error-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/error/ErrorFallback.tsx
  - src/components/error/AppErrorBoundary.tsx
  - src/components/ui/sonner.tsx
  - src/App.tsx
autonomous: true

must_haves:
  truths:
    - "App renders fallback UI when any component throws an error (instead of blank screen)"
    - "Error boundaries exist at app root and route level for granular error containment"
    - "Fallback UI shows user-friendly message with retry button"
    - "Error boundary resets when user navigates to different route"
  artifacts:
    - path: "src/components/error/ErrorFallback.tsx"
      provides: "Reusable fallback UI component with retry button"
      exports: ["ErrorFallback"]
    - path: "src/components/error/AppErrorBoundary.tsx"
      provides: "Configured ErrorBoundary wrapper with logging and reset"
      exports: ["AppErrorBoundary"]
    - path: "src/App.tsx"
      provides: "App wrapped with error boundaries at root and route levels"
      contains: "ErrorBoundary"
  key_links:
    - from: "src/App.tsx"
      to: "src/components/error/AppErrorBoundary.tsx"
      via: "import and wrap"
      pattern: "AppErrorBoundary"
    - from: "src/components/error/AppErrorBoundary.tsx"
      to: "react-error-boundary"
      via: "ErrorBoundary component"
      pattern: "ErrorBoundary.*FallbackComponent"
---

<objective>
Implement React Error Boundary infrastructure so users never see a blank screen from uncaught errors.

Purpose: Establishes error containment at app root and route levels. When any component throws during render, users see a friendly fallback UI with retry option instead of a broken page.

Output: ErrorFallback component, AppErrorBoundary wrapper, App.tsx wrapped with boundaries, Sonner configured with user-specified toast settings.
</objective>

<execution_context>
@/Users/haokunyang/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haokunyang/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-error-foundation/01-CONTEXT.md
@.planning/phases/01-error-foundation/01-RESEARCH.md

# Source files to reference
@src/App.tsx
@src/components/ui/sonner.tsx
@src/components/ui/button.tsx
@src/lib/utils.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install react-error-boundary and create error components</name>
  <files>
    - src/components/error/ErrorFallback.tsx
    - src/components/error/AppErrorBoundary.tsx
  </files>
  <action>
1. Install react-error-boundary:
   ```bash
   npm install react-error-boundary
   ```

2. Create `src/components/error/ErrorFallback.tsx`:
   - Import `FallbackProps` from react-error-boundary
   - Import Button from @/components/ui/button
   - Import cn from @/lib/utils
   - Create ErrorFallback component that accepts FallbackProps (error, resetErrorBoundary)
   - Render centered card-style container with:
     - Heading: "Something went wrong"
     - Subtext: "We encountered an unexpected error. Please try again."
     - Button with onClick={resetErrorBoundary} text "Try Again"
   - Use role="alert" for accessibility
   - Use existing Tailwind classes that match app style (rounded-lg, shadow-lg, bg-background, text-foreground)
   - Keep styling minimal per user decision (reliability milestone, not visual redesign)

3. Create `src/components/error/AppErrorBoundary.tsx`:
   - Import ErrorBoundary from react-error-boundary
   - Import useLocation from react-router-dom
   - Import ErrorFallback from ./ErrorFallback
   - Create AppErrorBoundary wrapper component that accepts children
   - Configure ErrorBoundary with:
     - FallbackComponent={ErrorFallback}
     - resetKeys={[location.pathname]} - auto-reset on route change
     - onError callback that logs structured error info:
       - timestamp (ISO string)
       - message (error.message)
       - stack (error.stack)
       - componentStack (info.componentStack)
       - url (window.location.href)
     - Wrap onError logic in try/catch to prevent logging failures from crashing
   - Export AppErrorBoundary as named export
  </action>
  <verify>
    - `ls src/components/error/` shows ErrorFallback.tsx and AppErrorBoundary.tsx
    - `npm run build` succeeds with no TypeScript errors
  </verify>
  <done>
    - ErrorFallback.tsx exports ErrorFallback component with FallbackProps interface
    - AppErrorBoundary.tsx exports AppErrorBoundary wrapper with resetKeys and onError configured
  </done>
</task>

<task type="auto">
  <name>Task 2: Configure Sonner and wrap App with error boundaries</name>
  <files>
    - src/components/ui/sonner.tsx
    - src/App.tsx
  </files>
  <action>
1. Update `src/components/ui/sonner.tsx`:
   - Add configuration props matching user decisions from CONTEXT.md:
     - position="bottom-right" (Claude's discretion)
     - duration={5000} (user decision: 5 seconds)
     - visibleToasts={3} (user decision: max 3)
     - closeButton={true} (user decision: X button for dismiss)
     - richColors={true} (user decision: distinct colors for error/success)
   - Keep existing toastOptions.classNames for shadcn styling
   - Merge spread props after explicit props so callers can override if needed

2. Update `src/App.tsx`:
   - Import AppErrorBoundary from @/components/error/AppErrorBoundary
   - Import useLocation from react-router-dom (needed for resetKeys)
   - Remove the Radix `<Toaster />` import and component (line 1 import, line 34 component)
   - Keep only `<Sonner />` for toast notifications (standardize on single toast system)

   Structure the component with error boundaries:
   - Move BrowserRouter to be the outermost wrapper (required for useLocation in AppErrorBoundary)
   - Wrap QueryClientProvider and everything inside with AppErrorBoundary
   - Add route-level ErrorBoundary around DashboardLayout route and StudentLayout route for granular containment

   Final structure should be:
   ```
   <BrowserRouter>
     <AppErrorBoundary>
       <QueryClientProvider>
         <TooltipProvider>
           <Sonner />
           <Routes>
             <Route path="/" ... />
             <Route path="/dashboard" element={
               <RouteErrorBoundary>
                 <DashboardLayout />
               </RouteErrorBoundary>
             }>...</Route>
             <Route path="/app" element={
               <RouteErrorBoundary>
                 <StudentLayout />
               </RouteErrorBoundary>
             }>...</Route>
             ...
           </Routes>
         </TooltipProvider>
       </QueryClientProvider>
     </AppErrorBoundary>
   </BrowserRouter>
   ```

   Note: For route-level boundaries, create a simple inline ErrorBoundary or create RouteErrorBoundary component that uses same ErrorFallback but doesn't need location-based resetKeys (parent already handles that).
  </action>
  <verify>
    - `npm run build` succeeds
    - `npm run dev` starts without errors
    - Verify in browser: open DevTools console, no warnings about duplicate toasters
    - Grep for "Toaster" in App.tsx should NOT find Radix Toaster import
  </verify>
  <done>
    - Sonner configured with 5s duration, max 3 visible, close button, rich colors
    - Radix Toaster removed from App.tsx
    - App wrapped with AppErrorBoundary at root
    - DashboardLayout and StudentLayout routes wrapped with route-level error boundary
  </done>
</task>

</tasks>

<verification>
After completing both tasks:

1. Build verification:
   ```bash
   npm run build
   ```
   Must succeed with no errors.

2. Manual error boundary test:
   - Temporarily add `throw new Error("Test error")` in any component (e.g., CoachDashboard)
   - Navigate to that route
   - Should see ErrorFallback UI instead of blank screen
   - Click "Try Again" button - should reset and attempt re-render
   - Remove the test throw

3. Toast configuration test:
   - Import toast from sonner in any component
   - Call `toast.error("Test error")`
   - Verify toast appears at bottom-right
   - Verify X button is present
   - Verify auto-dismisses after ~5 seconds
   - Trigger 4+ toasts rapidly - verify only 3 visible at once

4. Route-level boundary test:
   - Add throw in DashboardLayout child component
   - Navigate there - should see error UI
   - Navigation should still work (route-level boundary contains error)
   - Navigate away and back - error should reset
</verification>

<success_criteria>
- App never shows blank screen on component errors - fallback UI appears
- Error boundaries exist at app root (catches all) and route level (granular containment)
- Sonner is the only toast system (Radix Toaster removed)
- Toast config matches user decisions: 5s duration, 3 visible max, close button, distinct colors
- Error boundary auto-resets when route changes (via resetKeys)
- Build passes with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-error-foundation/01-01-SUMMARY.md` using summary template.
</output>
