---
phase: 08-component-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/ProtectedRoute.test.tsx
autonomous: true

must_haves:
  truths:
    - "Unauthenticated users are redirected to login page"
    - "Authenticated users can access protected content"
    - "Loading spinner shows during auth check"
    - "Role-based access redirects to correct dashboard"
  artifacts:
    - path: "src/components/ProtectedRoute.test.tsx"
      provides: "ProtectedRoute component tests"
      min_lines: 100
  key_links:
    - from: "src/components/ProtectedRoute.test.tsx"
      to: "src/components/ProtectedRoute.tsx"
      via: "import and render"
      pattern: "import.*ProtectedRoute"
    - from: "src/components/ProtectedRoute.test.tsx"
      to: "src/hooks/useAuth"
      via: "vi.mock"
      pattern: "vi\\.mock.*useAuth"
---

<objective>
Create comprehensive tests for ProtectedRoute component covering auth flow scenarios.

Purpose: Verify that authentication guards work correctly - blocking unauthenticated users, allowing authenticated users, and showing appropriate loading states. This fulfills requirement COMP-01.

Output: `src/components/ProtectedRoute.test.tsx` with tests for loading, unauthenticated redirect, authenticated access, and role-based routing.
</objective>

<execution_context>
@/Users/haokunyang/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haokunyang/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-component-tests/08-RESEARCH.md

# Source files
@src/components/ProtectedRoute.tsx
@src/hooks/useAuth.test.tsx
@src/test/test-utils.tsx
@src/test/mocks/supabase.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProtectedRoute test file with mocks and helpers</name>
  <files>src/components/ProtectedRoute.test.tsx</files>
  <action>
Create `src/components/ProtectedRoute.test.tsx` with:

1. Import setup:
   - `vi, describe, it, expect, beforeEach` from vitest
   - `render, screen, waitFor` from @testing-library/react
   - `Routes, Route, MemoryRouter` from react-router-dom
   - `ProtectedRoute` from ./ProtectedRoute
   - `getMockSupabase, resetMockSupabase` from @/test/mocks/supabase

2. Mock useAuth at module level using vi.mock:
   ```typescript
   vi.mock('@/hooks/useAuth');
   ```

3. Mock Supabase client for role fetching (use dynamic import pattern from useAuth.test.tsx):
   ```typescript
   vi.mock('@/integrations/supabase/client', async () => {
     const { getMockSupabase: getSupabase } = await import('@/test/mocks/supabase');
     return {
       supabase: new Proxy({}, {
         get: (_target: unknown, prop: string) => {
           const mock = getSupabase();
           return (mock?.client as Record<string, unknown>)?.[prop];
         },
       }),
     };
   });
   ```

4. Create helper function `renderWithRoutes(initialRoute, requiredRole?)` that renders:
   - MemoryRouter with initialEntries
   - Routes with:
     - `/` -> Login Page (data-testid="login-page")
     - `/app` -> Student Dashboard (data-testid="student-dashboard")
     - `/dashboard` -> Coach Dashboard (data-testid="coach-dashboard")
     - `/protected` -> ProtectedRoute wrapping Protected Content (data-testid="protected-content")

5. beforeEach:
   - Call resetMockSupabase()
   - Clear all vi mocks
  </action>
  <verify>File exists with correct imports and mock setup</verify>
  <done>Test file created with mocking infrastructure and render helper</done>
</task>

<task type="auto">
  <name>Task 2: Implement loading state and redirect tests</name>
  <files>src/components/ProtectedRoute.test.tsx</files>
  <action>
Add test suites to the test file:

**Loading state tests (describe block "loading state"):**

1. "shows loading spinner while auth is checking":
   - Mock useAuth to return `{ user: null, loading: true, ... }`
   - Render ProtectedRoute
   - Verify loading spinner exists via `document.querySelector('.animate-spin')`
   - Verify protected content NOT in document

2. "shows loading spinner while role is loading":
   - Mock useAuth with authenticated user but loading: false
   - Mock supabase single() to return a promise that never resolves
   - Render ProtectedRoute with requiredRole='coach'
   - Verify spinner shows (role fetch in progress)

**Unauthenticated redirect tests (describe block "unauthenticated state"):**

1. "redirects to login (/) when no user":
   - Mock useAuth: `{ user: null, loading: false, session: null, ... }`
   - Render ProtectedRoute
   - await waitFor to see login-page testid
   - Verify protected-content NOT in document

Use this useAuth mock shape (from ProtectedRoute.tsx usage):
```typescript
vi.mocked(useAuth).mockReturnValue({
  user: null,
  loading: false,
  session: null,
  signOut: vi.fn(),
  sessionExpired: false,
  clearSessionExpired: vi.fn(),
});
```
  </action>
  <verify>`npm test -- ProtectedRoute --run` shows loading and redirect tests passing</verify>
  <done>Loading spinner tests and unauthenticated redirect test pass</done>
</task>

<task type="auto">
  <name>Task 3: Implement authenticated and role-based access tests</name>
  <files>src/components/ProtectedRoute.test.tsx</files>
  <action>
Add remaining test suites:

**Authenticated access tests (describe block "authenticated state"):**

1. "renders children when user is authenticated (no role required)":
   - Mock useAuth with user object
   - Mock supabase setResponse with `{ data: { role: 'coach' }, error: null }`
   - Render ProtectedRoute without requiredRole
   - await waitFor to see protected-content testid

**Role-based access tests (describe block "role-based access"):**

Set up beforeEach with authenticated user mock.

1. "allows access when role matches required role":
   - setResponse `{ data: { role: 'coach' }, error: null }`
   - Render with requiredRole='coach'
   - Verify protected-content visible

2. "redirects coach to /dashboard when accessing student route":
   - setResponse `{ data: { role: 'coach' }, error: null }`
   - Render with requiredRole='student'
   - Verify coach-dashboard visible (redirect to /dashboard)

3. "redirects student to /app when accessing coach route":
   - setResponse `{ data: { role: 'student' }, error: null }`
   - Render with requiredRole='coach'
   - Verify student-dashboard visible (redirect to /app)

4. "redirects to login when role is null":
   - setResponse `{ data: { role: null }, error: null }`
   - Render with requiredRole='coach'
   - Verify login-page visible

Import useAuth from @/hooks/useAuth after mocks are declared but use the imported module with vi.mocked().
  </action>
  <verify>`npm test -- ProtectedRoute --run` shows all tests passing (expect ~7 tests)</verify>
  <done>All ProtectedRoute tests pass, covering loading, redirect, authenticated access, and role-based routing</done>
</task>

</tasks>

<verification>
```bash
# Run ProtectedRoute tests
npm test -- ProtectedRoute --run

# Should show:
# - loading state (2 tests)
# - unauthenticated state (1 test)
# - authenticated state (1 test)
# - role-based access (4 tests)
# All 8 tests passing
```
</verification>

<success_criteria>
1. ProtectedRoute.test.tsx exists with ~8 tests
2. Loading spinner test passes (auth loading AND role loading)
3. Unauthenticated redirect to "/" test passes
4. Authenticated access test passes
5. Role-based access tests pass (4 scenarios)
6. All tests run without warnings or errors
7. No test timeouts (all async properly awaited)
</success_criteria>

<output>
After completion, create `.planning/phases/08-component-tests/08-01-SUMMARY.md`
</output>
