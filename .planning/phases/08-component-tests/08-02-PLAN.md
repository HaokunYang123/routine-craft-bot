---
phase: 08-component-tests
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/CheckInModal.test.tsx
autonomous: true

must_haves:
  truths:
    - "Modal renders with title when open"
    - "User can select sentiment by clicking buttons"
    - "Notes field appears for tired/sore sentiments"
    - "Submit button disabled until sentiment selected"
    - "Successful submission calls callbacks and shows toast"
  artifacts:
    - path: "src/components/CheckInModal.test.tsx"
      provides: "CheckInModal component tests"
      min_lines: 120
  key_links:
    - from: "src/components/CheckInModal.test.tsx"
      to: "src/components/CheckInModal.tsx"
      via: "import and render"
      pattern: "import.*CheckInModal"
    - from: "src/components/CheckInModal.test.tsx"
      to: "src/hooks/useAuth"
      via: "vi.mock"
      pattern: "vi\\.mock.*useAuth"
---

<objective>
Create comprehensive tests for CheckInModal component covering user interaction and form submission.

Purpose: Verify that the check-in modal allows users to select their sentiment, optionally add notes, and submit successfully with appropriate feedback. This fulfills requirement COMP-02.

Output: `src/components/CheckInModal.test.tsx` with tests for rendering, sentiment selection, notes display, and form submission.
</objective>

<execution_context>
@/Users/haokunyang/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haokunyang/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-component-tests/08-RESEARCH.md

# Source files
@src/components/CheckInModal.tsx
@src/test/test-utils.tsx
@src/test/mocks/supabase.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CheckInModal test file with mocks and setup</name>
  <files>src/components/CheckInModal.test.tsx</files>
  <action>
Create `src/components/CheckInModal.test.tsx` with:

1. Import setup:
   - `vi, describe, it, expect, beforeEach` from vitest
   - `render, screen, waitFor` from @/test/test-utils
   - `userEvent` from @testing-library/user-event
   - `CheckInModal` from ./CheckInModal
   - `getMockSupabase, resetMockSupabase` from @/test/mocks/supabase

2. Mock useAuth:
   ```typescript
   vi.mock('@/hooks/useAuth');
   ```

3. Mock Supabase client (same pattern as ProtectedRoute tests):
   ```typescript
   vi.mock('@/integrations/supabase/client', async () => {
     const { getMockSupabase: getSupabase } = await import('@/test/mocks/supabase');
     return {
       supabase: new Proxy({}, {
         get: (_target: unknown, prop: string) => {
           const mock = getSupabase();
           return (mock?.client as Record<string, unknown>)?.[prop];
         },
       }),
     };
   });
   ```

4. Mock useToast to capture toast calls:
   ```typescript
   const mockToast = vi.fn();
   vi.mock('@/hooks/use-toast', () => ({
     useToast: () => ({ toast: mockToast }),
   }));
   ```

5. Import useAuth after mocks:
   ```typescript
   import { useAuth } from '@/hooks/useAuth';
   ```

6. Define defaultProps:
   ```typescript
   const defaultProps = {
     open: true,
     onOpenChange: vi.fn(),
     onCheckInComplete: vi.fn(),
   };
   ```

7. beforeEach:
   - resetMockSupabase()
   - localStorage.clear()
   - mockToast.mockClear()
   - defaultProps.onOpenChange.mockClear()
   - defaultProps.onCheckInComplete.mockClear()
   - Mock useAuth with authenticated user:
     ```typescript
     vi.mocked(useAuth).mockReturnValue({
       user: { id: 'student-1', email: 'student@example.com' } as any,
       session: {} as any,
       loading: false,
       signOut: vi.fn(),
       sessionExpired: false,
       clearSessionExpired: vi.fn(),
     });
     ```
   - Set default supabase response (no existing check-in):
     ```typescript
     getMockSupabase().setResponse({ data: null, error: null });
     ```
  </action>
  <verify>File exists with correct imports, mocks, and beforeEach setup</verify>
  <done>Test file created with mocking infrastructure</done>
</task>

<task type="auto">
  <name>Task 2: Implement rendering and sentiment selection tests</name>
  <files>src/components/CheckInModal.test.tsx</files>
  <action>
Add test suites:

**Rendering tests (describe block "rendering"):**

1. "renders dialog with title when open":
   - render CheckInModal with defaultProps
   - await waitFor to see dialog role
   - Verify title "How are you feeling today?" is in document

2. "does not render when open is false":
   - render CheckInModal with open: false
   - Verify queryByRole('dialog') returns null

3. "shows all sentiment options":
   - render CheckInModal
   - await waitFor to see dialog
   - Verify buttons exist: /great/i, /okay/i, /tired/i, /sore/i

**Sentiment selection tests (describe block "sentiment selection"):**

1. "highlights selected sentiment":
   - Setup userEvent with userEvent.setup()
   - render CheckInModal
   - await dialog to be visible
   - Click "great" button
   - Verify button has class 'border-primary'

2. "shows notes field for tired sentiment":
   - render CheckInModal
   - await dialog visible
   - Verify no textbox initially
   - Click "tired" button
   - Verify textbox appears with placeholder /sleep well/i or /Didn't sleep well/i

3. "shows notes field for sore sentiment":
   - render CheckInModal
   - Click "sore" button
   - Verify textbox appears

Note: CheckInModal buttons use explicit button elements, not Radix-specific. Use screen.getByRole('button', { name: /great/i }) pattern.
  </action>
  <verify>`npm test -- CheckInModal --run` shows rendering and selection tests passing</verify>
  <done>Rendering and sentiment selection tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Implement form submission and feedback tests</name>
  <files>src/components/CheckInModal.test.tsx</files>
  <action>
Add submission tests (describe block "form submission"):

1. "disables submit button until sentiment selected":
   - render CheckInModal
   - await dialog visible
   - Find submit button by /log check-in/i
   - Verify button is disabled (expect(button).toBeDisabled())

2. "enables submit button after sentiment selection":
   - render and click a sentiment
   - Verify submit button is NOT disabled

3. "submits check-in and calls callbacks on success":
   - Mock successful upsert:
     ```typescript
     getMockSupabase().queryBuilder.then.mockImplementationOnce((resolve) =>
       Promise.resolve({ data: null, error: null }).then(resolve)
     );
     ```
   - render CheckInModal
   - Select "great" sentiment
   - Click submit button
   - await waitFor onCheckInComplete called with 'great'
   - Verify onOpenChange called with false

4. "shows success toast for great/okay sentiments":
   - Mock successful upsert (same as above)
   - render, select "great", submit
   - await waitFor mockToast called with object containing title matching /Let's go/i

5. "shows supportive toast for tired/sore sentiments":
   - Mock successful upsert
   - render, select "tired", submit
   - await waitFor mockToast called with title matching /Take it easy/i

**Already checked in test (describe block "already checked in"):**

1. "closes modal when already checked in today (localStorage)":
   - Set localStorage: `localStorage.setItem('check_in_student-1', new Date().toISOString().split('T')[0])`
   - render CheckInModal
   - await waitFor onOpenChange called with false (modal closes)

Note: The submit button text is "Log Check-in" (saving state shows "Saving...").
  </action>
  <verify>`npm test -- CheckInModal --run` shows all tests passing (expect ~11 tests)</verify>
  <done>All CheckInModal tests pass, covering rendering, selection, submission, and feedback</done>
</task>

</tasks>

<verification>
```bash
# Run CheckInModal tests
npm test -- CheckInModal --run

# Should show:
# - rendering (3 tests)
# - sentiment selection (3 tests)
# - form submission (5 tests)
# - already checked in (1 test)
# All 12 tests passing
```
</verification>

<success_criteria>
1. CheckInModal.test.tsx exists with ~12 tests
2. Dialog renders correctly with title and all sentiment options
3. Sentiment selection highlights the button and conditionally shows notes
4. Submit button disabled/enabled state works correctly
5. Successful submission calls callbacks and shows appropriate toast
6. localStorage-based "already checked in" detection works
7. All tests run without warnings or errors
8. userEvent calls are all properly awaited
</success_criteria>

<output>
After completion, create `.planning/phases/08-component-tests/08-02-SUMMARY.md`
</output>
