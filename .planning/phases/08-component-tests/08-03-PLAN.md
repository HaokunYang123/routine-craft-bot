---
phase: 08-component-tests
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/pages/Dashboard.test.tsx
autonomous: true

must_haves:
  truths:
    - "Dashboard shows loading skeleton while fetching data"
    - "Dashboard displays user's display name after loading"
    - "Dashboard shows stats (people count, tasks, completed)"
    - "Dashboard renders quick action links"
  artifacts:
    - path: "src/pages/Dashboard.test.tsx"
      provides: "Dashboard component tests"
      min_lines: 80
  key_links:
    - from: "src/pages/Dashboard.test.tsx"
      to: "src/pages/Dashboard.tsx"
      via: "import and render"
      pattern: "import.*Dashboard"
    - from: "src/pages/Dashboard.test.tsx"
      to: "src/hooks/useAuth"
      via: "vi.mock"
      pattern: "vi\\.mock.*useAuth"
---

<objective>
Create tests for the Dashboard component covering data display and user interactions.

Purpose: Verify that the Dashboard correctly displays loading state, user information, stats counts, and quick action cards. This fulfills requirement COMP-03.

Output: `src/pages/Dashboard.test.tsx` with tests for loading state, data display, and UI elements.
</objective>

<execution_context>
@/Users/haokunyang/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haokunyang/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-component-tests/08-RESEARCH.md

# Source files
@src/pages/Dashboard.tsx
@src/test/test-utils.tsx
@src/test/mocks/supabase.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Dashboard test file with mocks and setup</name>
  <files>src/pages/Dashboard.test.tsx</files>
  <action>
Create `src/pages/Dashboard.test.tsx` with:

1. Import setup:
   - `vi, describe, it, expect, beforeEach` from vitest
   - `render, screen, waitFor` from @/test/test-utils
   - `Dashboard` from ./Dashboard (default export)
   - `getMockSupabase, resetMockSupabase` from @/test/mocks/supabase

2. Mock useAuth:
   ```typescript
   vi.mock('@/hooks/useAuth');
   ```

3. Mock Supabase client (same pattern as other tests):
   ```typescript
   vi.mock('@/integrations/supabase/client', async () => {
     const { getMockSupabase: getSupabase } = await import('@/test/mocks/supabase');
     return {
       supabase: new Proxy({}, {
         get: (_target: unknown, prop: string) => {
           const mock = getSupabase();
           return (mock?.client as Record<string, unknown>)?.[prop];
         },
       }),
     };
   });
   ```

4. Import useAuth after mocks:
   ```typescript
   import { useAuth } from '@/hooks/useAuth';
   ```

5. beforeEach:
   - resetMockSupabase()
   - Mock useAuth with authenticated coach user:
     ```typescript
     vi.mocked(useAuth).mockReturnValue({
       user: { id: 'coach-1', email: 'coach@example.com' } as any,
       session: {} as any,
       loading: false,
       signOut: vi.fn(),
       sessionExpired: false,
       clearSessionExpired: vi.fn(),
     });
     ```
  </action>
  <verify>File exists with correct imports and mock setup</verify>
  <done>Test file created with mocking infrastructure</done>
</task>

<task type="auto">
  <name>Task 2: Implement loading state and data display tests</name>
  <files>src/pages/Dashboard.test.tsx</files>
  <action>
Add test suites:

**Loading state tests (describe block "loading state"):**

1. "shows loading skeleton while fetching":
   - Make profile query never resolve:
     ```typescript
     getMockSupabase().queryBuilder.maybeSingle.mockImplementation(
       () => new Promise(() => {})
     );
     ```
   - render Dashboard
   - Verify skeleton is visible via `document.querySelector('.animate-pulse')`
   - Or check for DashboardSkeleton rendering

**Data display tests (describe block "data display"):**

1. "displays welcome message with user name after loading":
   - Mock profile response:
     ```typescript
     getMockSupabase().queryBuilder.maybeSingle.mockResolvedValueOnce({
       data: { display_name: 'Coach Jane' },
       error: null,
     });
     ```
   - Mock stats responses using then() for Promise.all queries:
     ```typescript
     const mock = getMockSupabase();
     // Each count query returns via then
     mock.queryBuilder.then
       .mockImplementationOnce((resolve) => Promise.resolve({ data: null, count: 5, error: null }).then(resolve))
       .mockImplementationOnce((resolve) => Promise.resolve({ data: null, count: 20, error: null }).then(resolve))
       .mockImplementationOnce((resolve) => Promise.resolve({ data: null, count: 15, error: null }).then(resolve));
     ```
   - render Dashboard
   - await waitFor to see "Welcome back, Coach Jane" (case insensitive: /welcome back.*coach jane/i)

2. "displays stats counts":
   - Use same mock setup as above (profile + 3 counts)
   - render Dashboard
   - await waitFor loading complete
   - Verify "5" appears (people count)
   - Verify "20" appears (total tasks)
   - Verify "15" appears (completed tasks)

Note: Dashboard uses Promise.all for [peopleRes, tasksRes, completedRes] after profile fetch. The mock needs to handle the sequence: profile first, then 3 parallel count queries.
  </action>
  <verify>`npm test -- Dashboard.test --run` shows loading and data display tests passing</verify>
  <done>Loading skeleton and data display tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Implement UI elements and interaction tests</name>
  <files>src/pages/Dashboard.test.tsx</files>
  <action>
Add remaining tests:

**UI elements tests (describe block "UI elements"):**

1. "renders stat cards with correct labels":
   - Mock profile and stats (same setup)
   - render Dashboard
   - await loading complete
   - Verify text "People" exists
   - Verify text "Total Tasks" exists
   - Verify text "Completed" exists
   - Verify text "Completion Rate" exists

2. "calculates and displays completion rate":
   - Mock stats: 20 total, 15 completed (= 75%)
   - render Dashboard
   - await loading complete
   - Verify "75%" appears in the document

3. "renders quick action cards with links":
   - Mock data (same setup)
   - render Dashboard
   - await loading complete
   - Verify "AI Assistant" text exists
   - Verify "Add a Person" text exists
   - Verify link to "/dashboard/assistant" exists
   - Verify link to "/dashboard/people" exists (use getByRole('link', { name: /add person/i }) or check href)

**Edge case tests:**

1. "shows 0% completion when no tasks":
   - Mock stats: 0 total, 0 completed
   - render Dashboard
   - Verify "0%" appears OR completion bar width is 0

Note: Use getByRole('link') for Links which render as <a> tags. Check href attribute or text content.
  </action>
  <verify>`npm test -- Dashboard.test --run` shows all tests passing (expect ~7 tests)</verify>
  <done>All Dashboard tests pass, covering loading, data display, UI elements, and edge cases</done>
</task>

</tasks>

<verification>
```bash
# Run Dashboard tests
npm test -- Dashboard.test --run

# Should show:
# - loading state (1 test)
# - data display (2 tests)
# - UI elements (3 tests)
# - edge case (1 test)
# All 7 tests passing
```
</verification>

<success_criteria>
1. Dashboard.test.tsx exists with ~7 tests
2. Loading skeleton test passes
3. Welcome message displays with user's display_name
4. Stats (people, tasks, completed) display correctly
5. Completion rate calculates and displays correctly
6. Quick action cards render with correct links
7. Edge case (0 tasks) handled gracefully
8. All tests run without warnings or errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-component-tests/08-03-SUMMARY.md`
</output>
