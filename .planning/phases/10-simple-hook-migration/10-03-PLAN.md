---
phase: 10-simple-hook-migration
plan: 03
type: execute
wave: 3
depends_on: ["10-02"]
files_modified:
  - src/hooks/useTemplates.ts
  - src/hooks/useTemplates.test.tsx
autonomous: true

must_haves:
  truths:
    - "User sees loading indicator when useTemplates fetches (isPending = true)"
    - "User sees cached templates instantly on navigation (no refetch within staleTime)"
    - "User sees error message when templates fetch fails (isError = true)"
    - "Component interface unchanged (templates, loading, fetchTemplates, mutations)"
  artifacts:
    - path: "src/hooks/useTemplates.ts"
      provides: "React Query-powered templates hook"
      contains: "useQuery"
      exports: ["useTemplates", "Template", "TemplateTask"]
    - path: "src/hooks/useTemplates.test.tsx"
      provides: "Tests for migrated useTemplates hook"
      contains: ["describe", "QueryClientProvider"]
  key_links:
    - from: "src/hooks/useTemplates.ts"
      to: "src/lib/queries/keys.ts"
      via: "queryKeys.templates.list"
      pattern: "queryKeys\\.templates\\.list"
    - from: "src/hooks/useTemplates.ts"
      to: "@tanstack/react-query"
      via: "useQuery import"
      pattern: "import.*useQuery.*@tanstack/react-query"
---

<objective>
Migrate useTemplates hook from useState/useEffect to React Query useQuery pattern.

Purpose: Third and final simple hook migration completes Phase 10. Templates have nested task fetching similar to groups.
Output: Working useTemplates hook using React Query with backward-compatible interface + test suite.
</objective>

<execution_context>
@/Users/haokunyang/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haokunyang/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-simple-hook-migration/10-CONTEXT.md
@.planning/phases/10-simple-hook-migration/10-RESEARCH.md
@.planning/phases/10-simple-hook-migration/10-02-SUMMARY.md

@src/hooks/useTemplates.ts
@src/lib/queries/keys.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate useTemplates to React Query</name>
  <files>src/hooks/useTemplates.ts</files>
  <action>
Replace useState/useEffect pattern with useQuery:

1. Add imports:
   ```typescript
   import { useQuery, useQueryClient } from '@tanstack/react-query';
   import { queryKeys } from '@/lib/queries/keys';
   ```

2. Extract queryFn to separate async function `fetchTemplatesWithTasks(userId)`:
   - Move the templates fetch + nested tasks logic
   - Return Template[] (not void)
   - Handle PGRST205 gracefully (table not exist -> return [])
   - Throw other errors (let React Query handle)
   ```typescript
   async function fetchTemplatesWithTasks(userId: string): Promise<Template[]> {
     const { data: templatesData, error: templatesError } = await supabase
       .from("templates")
       .select("*")
       .eq("coach_id", userId)
       .order("created_at", { ascending: false });

     // Table doesn't exist yet - return empty (not an error)
     if (templatesError) {
       if (templatesError.code === "PGRST205" || templatesError.message?.includes("not find")) {
         console.log("Templates table not yet created - run the SQL migration");
         return [];
       }
       throw templatesError;
     }

     // Fetch tasks for each template
     const templatesWithTasks = await Promise.all(
       (templatesData || []).map(async (template) => {
         const { data: tasksData } = await supabase
           .from("template_tasks")
           .select("*")
           .eq("template_id", template.id)
           .order("day_offset", { ascending: true })
           .order("sort_order", { ascending: true });
         return { ...template, tasks: tasksData || [] };
       })
     );

     return templatesWithTasks;
   }
   ```

3. Replace hook internals:
   ```typescript
   const queryClient = useQueryClient();

   const {
     data: templates,
     isPending,
     isFetching,
     isError,
     error,
     refetch,
   } = useQuery({
     queryKey: queryKeys.templates.list(user?.id ?? ''),
     queryFn: () => fetchTemplatesWithTasks(user!.id),
     enabled: !!user,
   });
   ```

4. Keep return interface backward-compatible:
   ```typescript
   return {
     templates: templates ?? [],     // Coerce undefined to empty array
     loading: isPending,             // Keep "loading" name
     isFetching,                     // NEW: for background refresh indicator
     isError,                        // NEW: for error UI
     error,                          // NEW: for error details
     fetchTemplates: refetch,        // Manual retry
     createTemplate,                 // Keep existing
     updateTemplate,                 // Keep existing
     deleteTemplate,                 // Keep existing
   };
   ```

5. Update all mutation functions to use queryClient.invalidateQueries:
   - createTemplate: after success, `await queryClient.invalidateQueries({ queryKey: queryKeys.templates.list(user.id) })`
   - updateTemplate: same invalidation
   - deleteTemplate: can keep optimistic local filter + invalidation

6. Remove local setTemplates calls from mutations - let invalidation refetch fresh data.

IMPORTANT:
- Remove useState for templates and loading
- Remove useEffect that calls fetchTemplates
- Keep Template and TemplateTask interface exports unchanged
- Global error handler handles toasts - do NOT add per-hook toast on fetch errors
  </action>
  <verify>
Run `npm run build` - no TypeScript errors.
Grep for "useQuery" in useTemplates.ts - should find import and usage.
  </verify>
  <done>
useTemplates hook uses React Query useQuery with:
- queryKeys.templates.list for cache key
- enabled: !!user guard
- isPending/isFetching/isError exposed
- templates ?? [] for backward compatibility
- All mutations use invalidateQueries
- PGRST205 handled gracefully (returns empty, not error)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useTemplates test suite</name>
  <files>src/hooks/useTemplates.test.tsx</files>
  <action>
Create comprehensive test file following established patterns from useGroups.test.tsx:

1. Setup mocks (same pattern as other hook tests):
   ```typescript
   vi.mock('@/integrations/supabase/client', async () => {
     const actual = await import('@/test/mocks/supabase');
     return actual.mockSupabaseModule;
   });
   vi.mock('./useAuth');
   vi.mock('./use-toast');
   vi.mock('@/lib/error', () => ({ handleError: vi.fn() }));
   ```

2. Create wrapper with QueryClientProvider:
   ```typescript
   function createWrapper() {
     const queryClient = new QueryClient({
       defaultOptions: { queries: { retry: false } },
     });
     return ({ children }: { children: React.ReactNode }) => (
       <QueryClientProvider client={queryClient}>
         <MemoryRouter>{children}</MemoryRouter>
       </QueryClientProvider>
     );
   }
   ```

3. Test cases:
   describe('fetchTemplates'):
   - `returns loading state initially` - isPending true before fetch
   - `returns templates with tasks on successful fetch` - templates populated, loading false
   - `handles PGRST205 gracefully (table not exist)` - returns empty, no error
   - `handles fetch error` - isError true, templates empty
   - `does not fetch when user is null` - query disabled

   describe('createTemplate'):
   - `creates template with tasks` - inserts template + tasks
   - `shows success toast` - toast called with correct message
   - `invalidates cache after create` - invalidateQueries called
   - `returns null when user is null` - no action

   describe('updateTemplate'):
   - `updates template and replaces tasks` - deletes old tasks, inserts new
   - `shows success toast` - toast called
   - `invalidates cache after update` - invalidateQueries called

   describe('deleteTemplate'):
   - `deletes template` - delete called
   - `shows success toast` - toast called
   - `handles delete error` - error handling

4. Mock Supabase responses appropriately for nested queries (templates + template_tasks).
  </action>
  <verify>
Run `npm test src/hooks/useTemplates.test.tsx` - all tests pass.
  </verify>
  <done>
useTemplates.test.tsx exists with tests for:
- Loading state
- Successful fetch with tasks
- PGRST205 graceful handling
- Error handling
- Disabled when no user
- All mutation operations
- Cache invalidation
  </done>
</task>

</tasks>

<verification>
1. `npm run build` - TypeScript compiles without errors
2. `npm test src/hooks/useTemplates.test.tsx` - all tests pass
3. `npm test` - all tests pass (no regressions)
4. `grep -n "useQuery" src/hooks/useTemplates.ts` - confirms React Query usage
5. `grep -n "queryKeys.templates" src/hooks/useTemplates.ts` - confirms key factory usage
6. `grep -n "invalidateQueries" src/hooks/useTemplates.ts` - confirms cache invalidation
</verification>

<success_criteria>
- useTemplates.ts uses useQuery with queryKeys.templates.list
- Return interface unchanged (templates, loading, fetchTemplates, mutations)
- New properties exposed: isFetching, isError, error
- PGRST205 error handled gracefully (returns empty, not thrown)
- All mutation functions use invalidateQueries
- Comprehensive test suite created
- All tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/10-simple-hook-migration/10-03-SUMMARY.md`
</output>
