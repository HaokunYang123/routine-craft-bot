---
phase: 10-simple-hook-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useProfile.ts
  - src/hooks/useProfile.test.tsx
autonomous: true

must_haves:
  truths:
    - "User sees loading indicator when useProfile fetches (isPending = true)"
    - "User sees profile data after successful fetch"
    - "User sees cached profile instantly on navigation (no refetch within staleTime)"
    - "Component interface unchanged (profile, loading, fetchProfile exports)"
  artifacts:
    - path: "src/hooks/useProfile.ts"
      provides: "React Query-powered profile hook"
      contains: "useQuery"
      exports: ["useProfile", "Profile"]
    - path: "src/hooks/useProfile.test.tsx"
      provides: "Tests for migrated useProfile hook"
      contains: ["describe", "useProfile"]
  key_links:
    - from: "src/hooks/useProfile.ts"
      to: "src/lib/queries/keys.ts"
      via: "queryKeys.profile.current"
      pattern: "queryKeys\\.profile\\.current"
    - from: "src/hooks/useProfile.ts"
      to: "@tanstack/react-query"
      via: "useQuery import"
      pattern: "import.*useQuery.*@tanstack/react-query"
---

<objective>
Migrate useProfile hook from useState/useEffect to React Query useQuery pattern.

Purpose: First migration establishes the pattern for remaining hooks. Profile is simplest (single entity fetch with auto-creation).
Output: Working useProfile hook using React Query with backward-compatible interface + test suite.
</objective>

<execution_context>
@/Users/haokunyang/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haokunyang/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-simple-hook-migration/10-CONTEXT.md
@.planning/phases/10-simple-hook-migration/10-RESEARCH.md
@.planning/phases/09-react-query-foundation/09-01-SUMMARY.md

@src/hooks/useProfile.ts
@src/lib/queries/keys.ts
@src/test/test-utils.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate useProfile to React Query</name>
  <files>src/hooks/useProfile.ts</files>
  <action>
Replace useState/useEffect pattern with useQuery:

1. Add imports:
   ```typescript
   import { useQuery, useQueryClient } from '@tanstack/react-query';
   import { queryKeys } from '@/lib/queries/keys';
   ```

2. Extract queryFn to separate async function `fetchOrCreateProfile(userId, email, metadata)`:
   - Move the fetch + auto-create profile logic from existing fetchProfile
   - Return Profile (not void)
   - Throw errors (don't catch internally - let React Query handle)

3. Replace hook internals:
   ```typescript
   const queryClient = useQueryClient();

   const {
     data: profile,
     isPending,
     isFetching,
     isError,
     error,
     refetch,
   } = useQuery({
     queryKey: queryKeys.profile.current(user?.id ?? ''),
     queryFn: () => fetchOrCreateProfile(user!.id, user!.email, user!.user_metadata),
     enabled: !!user,
   });
   ```

4. Keep return interface backward-compatible:
   ```typescript
   return {
     profile: profile ?? null,     // Coerce undefined to null
     loading: isPending,           // Keep "loading" name
     isFetching,                   // NEW: for background refresh indicator
     isError,                      // NEW: for error UI
     error,                        // NEW: for error details
     displayName,                  // Unchanged
     initials,                     // Unchanged
     avatarEmoji,                  // Unchanged
     avatarDisplay,                // Unchanged
     fetchProfile: refetch,        // Manual retry
     updateProfile,                // Keep existing mutation logic
   };
   ```

5. Update updateProfile to use queryClient.invalidateQueries:
   - After successful update: `await queryClient.invalidateQueries({ queryKey: queryKeys.profile.current(user.id) })`
   - Remove local setProfile call (let invalidation refetch)

IMPORTANT:
- Remove useState for profile and loading
- Remove useEffect that calls fetchProfile
- Remove useCallback wrapper from fetchProfile (not needed with useQuery)
- Keep the Profile interface export unchanged
- Global error handler (QueryCache.onError) handles toasts - do NOT add per-hook toast on fetch errors
  </action>
  <verify>
Run `npm run build` - no TypeScript errors.
Grep for "useQuery" in useProfile.ts - should find import and usage.
  </verify>
  <done>
useProfile hook uses React Query useQuery with:
- queryKeys.profile.current for cache key
- enabled: !!user guard
- isPending/isFetching/isError exposed
- profile ?? null for backward compatibility
- updateProfile uses invalidateQueries
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useProfile test suite</name>
  <files>src/hooks/useProfile.test.tsx</files>
  <action>
Create comprehensive test file following existing patterns from useGroups.test.tsx:

1. Setup mocks:
   ```typescript
   vi.mock('@/integrations/supabase/client', async () => {
     const actual = await import('@/test/mocks/supabase');
     return actual.mockSupabaseModule;
   });
   vi.mock('./useAuth');
   vi.mock('./use-toast');
   vi.mock('@/lib/error', () => ({ handleError: vi.fn() }));
   ```

2. Create wrapper with QueryClientProvider:
   ```typescript
   function createWrapper() {
     const queryClient = new QueryClient({
       defaultOptions: { queries: { retry: false } },
     });
     return ({ children }: { children: React.ReactNode }) => (
       <QueryClientProvider client={queryClient}>
         <MemoryRouter>{children}</MemoryRouter>
       </QueryClientProvider>
     );
   }
   ```

3. Test cases:
   - `returns loading state initially` - isPending is true before fetch completes
   - `returns profile data on successful fetch` - profile populated, loading false
   - `creates profile when not found (PGRST116)` - auto-create on missing profile
   - `handles fetch error` - isError true, profile null
   - `does not fetch when user is null` - query disabled, no Supabase calls
   - `updateProfile invalidates cache` - calls invalidateQueries after update
   - `computes displayName/initials/avatar correctly` - helper values work

4. Use waitFor for async state changes:
   ```typescript
   await waitFor(() => expect(result.current.loading).toBe(false));
   ```

5. Mock Supabase responses using getMockSupabase():
   ```typescript
   mock.queryBuilder.single.mockResolvedValueOnce({ data: mockProfile, error: null });
   ```
  </action>
  <verify>
Run `npm test src/hooks/useProfile.test.tsx` - all tests pass.
  </verify>
  <done>
useProfile.test.tsx exists with tests for:
- Loading state
- Successful fetch
- Profile auto-creation
- Error handling
- Disabled when no user
- Cache invalidation on update
  </done>
</task>

</tasks>

<verification>
1. `npm run build` - TypeScript compiles without errors
2. `npm test src/hooks/useProfile.test.tsx` - all tests pass
3. `npm test` - all 103+ tests pass (no regressions)
4. `grep -n "useQuery" src/hooks/useProfile.ts` - confirms React Query usage
5. `grep -n "queryKeys.profile" src/hooks/useProfile.ts` - confirms key factory usage
</verification>

<success_criteria>
- useProfile.ts uses useQuery with queryKeys.profile.current
- Return interface unchanged (profile, loading, fetchProfile, etc.)
- New properties exposed: isFetching, isError, error
- updateProfile uses invalidateQueries instead of setProfile
- Test suite covers loading, success, error, disabled, update scenarios
- All existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/10-simple-hook-migration/10-01-SUMMARY.md`
</output>
