---
phase: 11-complex-hook-migration
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useStickers.ts
  - src/hooks/useStickers.test.tsx
autonomous: true

must_haves:
  truths:
    - "User sees loading indicator when useStickers fetches"
    - "User sees cached sticker data instantly on navigation"
    - "User sees current streak calculated from completed tasks"
    - "User sees all three data sources (stickers, userStickers, completedTasks) loaded"
    - "rollForSticker mutation awards sticker and invalidates cache"
  artifacts:
    - path: "src/hooks/useStickers.ts"
      provides: "React Query migrated hook with useQueries"
      contains: "useQueries"
    - path: "src/hooks/useStickers.test.tsx"
      provides: "Comprehensive test coverage"
      min_lines: 100
  key_links:
    - from: "src/hooks/useStickers.ts"
      to: "src/lib/queries/keys.ts"
      via: "queryKeys.stickers import"
      pattern: "queryKeys\\.stickers"
    - from: "src/hooks/useStickers.ts"
      to: "@tanstack/react-query"
      via: "useQueries with combine"
      pattern: "useQueries.*combine"
---

<objective>
Migrate useStickers from useState/useEffect to React Query useQueries with combine option.

Purpose: Replace manual Promise.all in useEffect with useQueries for parallel fetching with automatic loading/error state management. Move streak calculation into combine function for derived state handling.

Output:
- Migrated useStickers.ts using useQueries with combine for parallel queries
- Comprehensive test suite verifying parallel loading, streak calculation, and rollForSticker
</objective>

<execution_context>
@/Users/haokunyang/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haokunyang/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-complex-hook-migration/11-RESEARCH.md

# Established patterns
@.planning/phases/10-simple-hook-migration/10-02-SUMMARY.md

# Files to modify
@src/hooks/useStickers.ts
@src/lib/queries/keys.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate useStickers to React Query useQueries with combine</name>
  <files>src/hooks/useStickers.ts</files>
  <action>
Migrate useStickers from useState/useEffect/Promise.all to useQueries with combine:

1. Add imports:
   ```typescript
   import { useQueries, useQueryClient } from "@tanstack/react-query";
   import { queryKeys } from "@/lib/queries/keys";
   ```

2. Extract streak calculation as pure function (before hook):
   ```typescript
   function calculateStreak(completedTasks: { completed_at: string | null }[]): number {
     const dates = completedTasks
       .filter(t => t.completed_at !== null)
       .map(t => new Date(t.completed_at!).toDateString());
     const uniqueDates = [...new Set(dates)];

     const today = new Date().toDateString();
     const yesterday = new Date(Date.now() - 86400000).toDateString();

     let currentStreak = 0;

     if (uniqueDates.includes(today)) {
       currentStreak = 1;
       let checkDate = new Date(Date.now() - 86400000);
       while (uniqueDates.includes(checkDate.toDateString())) {
         currentStreak++;
         checkDate.setDate(checkDate.getDate() - 1);
       }
     } else if (uniqueDates.includes(yesterday)) {
       let checkDate = new Date(Date.now() - 86400000);
       while (uniqueDates.includes(checkDate.toDateString())) {
         currentStreak++;
         checkDate.setDate(checkDate.getDate() - 1);
       }
     }

     return currentStreak;
   }
   ```

3. Replace useState/useEffect with useQueries:
   ```typescript
   export function useStickers() {
     const { user } = useAuth();
     const { toast } = useToast();
     const queryClient = useQueryClient();

     const results = useQueries({
       queries: [
         {
           queryKey: ['stickers', 'all'],
           queryFn: async () => {
             const { data, error } = await supabase.from("stickers").select("*");
             if (error) throw error;
             return data || [];
           },
           enabled: !!user,
         },
         {
           queryKey: queryKeys.stickers.byUser(user?.id ?? ''),
           queryFn: async () => {
             const { data, error } = await supabase
               .from("user_stickers")
               .select("*, sticker:stickers(*)")
               .eq("user_id", user!.id)
               .order("earned_at", { ascending: false });
             if (error) throw error;
             return data || [];
           },
           enabled: !!user,
         },
         {
           queryKey: ['tasks', 'completed', user?.id ?? ''],
           queryFn: async () => {
             const { data, error } = await supabase
               .from("tasks")
               .select("completed_at")
               .eq("user_id", user!.id)
               .eq("is_completed", true)
               .order("completed_at", { ascending: false });
             if (error) throw error;
             return data || [];
           },
           enabled: !!user,
         },
       ],
       combine: (results) => {
         const [stickersResult, userStickersResult, tasksResult] = results;

         // Calculate streak from completed tasks (moved from useEffect)
         const streak = calculateStreak(tasksResult.data || []);

         return {
           stickers: stickersResult.data || [],
           userStickers: (userStickersResult.data || []) as UserSticker[],
           streak,
           isPending: results.some(r => r.isPending),
           isFetching: results.some(r => r.isFetching),
           isError: results.some(r => r.isError),
           error: results.find(r => r.error)?.error,
         };
       },
     });
   ```

4. Update rollForSticker to use invalidateQueries:
   ```typescript
   const rollForSticker = useCallback(async (taskId: string): Promise<Sticker | null> => {
     if (!user || results.stickers.length === 0) return null;

     // 20% chance to drop
     if (Math.random() > DROP_CHANCE) return null;

     // Weighted random selection by rarity
     const weightedStickers = results.stickers.flatMap((sticker) => {
       const weight = RARITY_WEIGHTS[sticker.rarity as keyof typeof RARITY_WEIGHTS] || 10;
       return Array(weight).fill(sticker);
     });

     const randomSticker = weightedStickers[Math.floor(Math.random() * weightedStickers.length)];

     // Award the sticker
     const { error } = await supabase.from("user_stickers").insert({
       user_id: user.id,
       sticker_id: randomSticker.id,
       task_id: taskId,
     });

     if (error) {
       handleError(error, { component: 'useStickers', action: 'award sticker', silent: true });
       return null;
     }

     // Show toast notification
     toast({
       title: `You found a ${randomSticker.rarity} sticker!`,
       description: `"${randomSticker.name}" added to your Sticker Book!`,
     });

     // Invalidate cache to refresh user stickers
     await queryClient.invalidateQueries({ queryKey: queryKeys.stickers.byUser(user.id) });

     return randomSticker;
   }, [user, results.stickers, toast, queryClient]);
   ```

5. Update return statement for backward compatibility:
   ```typescript
   return {
     stickers: results.stickers,
     userStickers: results.userStickers,
     streak: results.streak,
     loading: results.isPending,      // Backward compatible
     isFetching: results.isFetching,  // NEW
     isError: results.isError,        // NEW
     error: results.error,            // NEW
     rollForSticker,
     refetch: () => queryClient.invalidateQueries({ queryKey: queryKeys.stickers.byUser(user?.id ?? '') }),
   };
   ```

Key patterns from research:
- useQueries with combine for parallel data sources
- streak calculation in combine (derived state)
- All three queries use same `enabled: !!user` guard
- Loading state is true if ANY query is pending
- Error state is true if ANY query has error
  </action>
  <verify>
Run TypeScript compilation: `npx tsc --noEmit`
Verify no type errors in useStickers.ts
  </verify>
  <done>
useStickers.ts uses useQueries with combine option, streak calculated in combine function, rollForSticker uses invalidateQueries, backward-compatible interface maintained
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useStickers test suite</name>
  <files>src/hooks/useStickers.test.tsx</files>
  <action>
Create comprehensive test suite for migrated useStickers hook:

1. Create test file with proper setup:
   ```typescript
   import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
   import { renderHook, waitFor, act } from '@testing-library/react';
   import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
   import { ReactNode } from 'react';
   import { useStickers } from './useStickers';

   // Mock dependencies
   vi.mock('./useAuth', () => ({
     useAuth: vi.fn(),
   }));
   vi.mock('./use-toast', () => ({
     useToast: vi.fn(() => ({ toast: vi.fn() })),
   }));

   // Create mock for Supabase
   const mockFrom = vi.fn();
   vi.mock('@/integrations/supabase/client', () => ({
     supabase: {
       from: (...args: any[]) => mockFrom(...args),
     },
   }));
   ```

2. Create wrapper helper:
   ```typescript
   function createWrapper() {
     const queryClient = new QueryClient({
       defaultOptions: {
         queries: { retry: false, gcTime: 0 },
       },
     });
     return ({ children }: { children: ReactNode }) => (
       <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
     );
   }
   ```

3. Test suites to implement:

   **Loading state tests:**
   - "shows loading state initially when fetching"
   - "sets loading to false after all queries complete"
   - "shows isFetching during background refetch"

   **Parallel fetch tests:**
   - "fetches all three data sources in parallel"
   - "returns stickers array from stickers table"
   - "returns userStickers with joined sticker data"
   - "returns completedTasks for streak calculation"

   **Streak calculation tests:**
   - "calculates streak of 0 when no tasks completed"
   - "calculates streak of 1 when task completed today"
   - "calculates streak of N for consecutive days"
   - "preserves streak from yesterday if no task today"
   - "resets streak after gap in completion"

   **Error handling tests:**
   - "sets isError true if any query fails"
   - "exposes error from first failing query"
   - "partial failure still returns available data"

   **Cache behavior tests:**
   - "uses cached data on subsequent renders"
   - "all queries refetch when user changes"

   **rollForSticker tests:**
   - "returns null when user is null"
   - "returns null when stickers array is empty"
   - "returns null 80% of time (respects DROP_CHANCE)"
   - "awards sticker and shows toast on success"
   - "invalidates userStickers cache after award"
   - "handles insert error gracefully"

   **refetch tests:**
   - "refetch invalidates userStickers cache"

   **Auth guard tests:**
   - "does not fetch when user is null"
   - "returns empty arrays when not authenticated"

4. Key testing patterns:
   - Mock Math.random() to control drop chance
   - Use different mockFrom implementations per test
   - Verify parallel execution by checking all three queries triggered
   - Test streak calculation edge cases (today, yesterday, gaps)
  </action>
  <verify>
Run tests: `npm test -- --run src/hooks/useStickers.test.tsx`
All tests should pass
Run full suite: `npm test -- --run`
All existing tests still pass
  </verify>
  <done>
useStickers.test.tsx exists with 20+ tests covering parallel fetching, streak calculation, rollForSticker, error handling, and cache behavior. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - No TypeScript errors
2. `npm test -- --run src/hooks/useStickers.test.tsx` - All hook tests pass
3. `npm test -- --run` - All existing tests still pass
4. Verify parallel loading: All three queries should start simultaneously (not waterfall)
</verification>

<success_criteria>
- useStickers.ts uses useQueries with combine option
- Three parallel queries: stickers, userStickers, completedTasks
- Streak calculated in combine function (not useEffect)
- rollForSticker uses invalidateQueries instead of fetchStickers()
- Backward-compatible interface maintained (stickers, userStickers, streak, loading, rollForSticker, refetch)
- New properties exposed (isFetching, isError, error)
- Test suite has 20+ tests covering parallel fetching, streak calculation, and mutations
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-complex-hook-migration/11-03-SUMMARY.md`
</output>
