---
phase: 11-complex-hook-migration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useRecurringSchedules.ts
  - src/hooks/useRecurringSchedules.test.tsx
autonomous: true

must_haves:
  truths:
    - "User sees loading indicator when useRecurringSchedules fetches"
    - "User sees cached schedules instantly on navigation"
    - "User sees error message when fetch fails"
    - "Schedule data includes enriched names (template, student, class)"
    - "Mutations invalidate cache and refresh data"
  artifacts:
    - path: "src/hooks/useRecurringSchedules.ts"
      provides: "React Query migrated hook with nested enrichment"
      contains: "useQuery"
    - path: "src/hooks/useRecurringSchedules.test.tsx"
      provides: "Comprehensive test coverage"
      min_lines: 100
  key_links:
    - from: "src/hooks/useRecurringSchedules.ts"
      to: "src/lib/queries/keys.ts"
      via: "queryKeys.recurringSchedules import"
      pattern: "queryKeys\\.recurringSchedules"
    - from: "src/hooks/useRecurringSchedules.ts"
      to: "supabase.from"
      via: "parallel enrichment queries"
      pattern: "Promise\\.all"
---

<objective>
Migrate useRecurringSchedules from useState/useEffect to React Query useQuery with nested data enrichment.

Purpose: Replace manual fetch/setState with useQuery for automatic caching. Optimize nested enrichment queries to run in parallel using Promise.all. Handle PGRST205 gracefully per D-1003-01.

Output:
- Migrated useRecurringSchedules.ts using useQuery with parallel enrichment
- Comprehensive test suite verifying loading, caching, enrichment, and CRUD operations
</objective>

<execution_context>
@/Users/haokunyang/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haokunyang/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-complex-hook-migration/11-RESEARCH.md

# Established patterns
@.planning/phases/10-simple-hook-migration/10-02-SUMMARY.md

# Files to modify
@src/hooks/useRecurringSchedules.ts
@src/lib/queries/keys.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate useRecurringSchedules to React Query with parallel enrichment</name>
  <files>src/hooks/useRecurringSchedules.ts</files>
  <action>
Migrate useRecurringSchedules from useState/useEffect to useQuery:

1. Add imports:
   ```typescript
   import { useQuery, useQueryClient } from "@tanstack/react-query";
   import { queryKeys } from "@/lib/queries/keys";
   ```

2. Extract queryFn as standalone async function (BEFORE the hook):
   ```typescript
   async function fetchSchedulesWithEnrichment(userId: string): Promise<RecurringSchedule[]> {
     const { data: schedules, error } = await supabase
       .from("recurring_schedules")
       .select("*")
       .eq("user_id", userId)
       .order("created_at", { ascending: false });

     if (error) {
       // Handle PGRST205 gracefully per D-1003-01
       if (error.code === "PGRST205" || error.message?.includes("not find")) {
         return [];
       }
       throw error;
     }

     if (!schedules?.length) return [];

     // Collect IDs for batch fetching (avoid waterfall)
     const templateIds = [...new Set(schedules.filter(s => s.template_id).map(s => s.template_id!))];
     const studentIds = [...new Set(schedules.filter(s => s.assigned_student_id).map(s => s.assigned_student_id!))];
     const classIds = [...new Set(schedules.filter(s => s.class_session_id).map(s => s.class_session_id!))];

     // Parallel fetch enrichment data
     const [templates, profiles, classes] = await Promise.all([
       templateIds.length > 0
         ? supabase.from("templates").select("id, name").in("id", templateIds)
         : Promise.resolve({ data: [] as { id: string; name: string }[] }),
       studentIds.length > 0
         ? supabase.from("profiles").select("user_id, display_name").in("user_id", studentIds)
         : Promise.resolve({ data: [] as { user_id: string; display_name: string | null }[] }),
       classIds.length > 0
         ? supabase.from("class_sessions").select("id, name").in("id", classIds)
         : Promise.resolve({ data: [] as { id: string; name: string }[] }),
     ]);

     // Build lookup maps
     const templateMap: Record<string, string> = {};
     (templates.data || []).forEach(t => { templateMap[t.id] = t.name; });

     const studentMap: Record<string, string> = {};
     (profiles.data || []).forEach(p => { studentMap[p.user_id] = p.display_name || "Student"; });

     const classMap: Record<string, string> = {};
     (classes.data || []).forEach(c => { classMap[c.id] = c.name; });

     // Enrich schedules
     return schedules.map(s => ({
       ...s,
       template_name: s.template_id ? templateMap[s.template_id] : undefined,
       student_name: s.assigned_student_id ? studentMap[s.assigned_student_id] : undefined,
       class_name: s.class_session_id ? classMap[s.class_session_id] : undefined,
     }));
   }
   ```

3. Replace useState/useEffect with useQuery in hook:
   ```typescript
   export function useRecurringSchedules() {
     const { user } = useAuth();
     const { toast } = useToast();
     const queryClient = useQueryClient();

     const {
       data: schedules,
       isPending,
       isFetching,
       isError,
       error,
       refetch,
     } = useQuery({
       queryKey: queryKeys.recurringSchedules.list(user?.id ?? ''),
       queryFn: () => fetchSchedulesWithEnrichment(user!.id),
       enabled: !!user,
     });

     // ... mutations stay as async functions
   ```

4. Update CRUD mutations to use invalidateQueries:
   - In createSchedule: Replace `await fetchSchedules();` with `await queryClient.invalidateQueries({ queryKey: queryKeys.recurringSchedules.list(user.id) });`
   - In updateSchedule: Replace `await fetchSchedules();` with `await queryClient.invalidateQueries({ queryKey: queryKeys.recurringSchedules.list(user!.id) });`
   - In deleteSchedule: Replace `setSchedules((prev) => ...)` with `await queryClient.invalidateQueries({ queryKey: queryKeys.recurringSchedules.list(user!.id) });`

5. Update return statement for backward compatibility:
   ```typescript
   return {
     schedules: schedules ?? [],
     loading: isPending,         // Backward compatible
     isFetching,                 // NEW
     isError,                    // NEW
     error,                      // NEW
     fetchSchedules: refetch,
     createSchedule,
     updateSchedule,
     deleteSchedule,
     generateTasks,
   };
   ```

Key patterns from research:
- Extract queryFn for testability
- Use Promise.all for parallel enrichment (templates, profiles, classes fetched concurrently)
- Handle PGRST205 by returning empty array (per D-1003-01)
- Global error handler handles toasts - don't duplicate
  </action>
  <verify>
Run TypeScript compilation: `npx tsc --noEmit`
Verify no type errors in useRecurringSchedules.ts
  </verify>
  <done>
useRecurringSchedules.ts uses useQuery with parallel enrichment in queryFn, PGRST205 handled gracefully, all mutations use invalidateQueries, backward-compatible interface maintained
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useRecurringSchedules test suite</name>
  <files>src/hooks/useRecurringSchedules.test.tsx</files>
  <action>
Create comprehensive test suite for migrated useRecurringSchedules hook:

1. Create test file with proper setup:
   ```typescript
   import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
   import { renderHook, waitFor, act } from '@testing-library/react';
   import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
   import { ReactNode } from 'react';
   import { useRecurringSchedules } from './useRecurringSchedules';

   // Mock dependencies
   vi.mock('./useAuth', () => ({
     useAuth: vi.fn(),
   }));
   vi.mock('./use-toast', () => ({
     useToast: vi.fn(() => ({ toast: vi.fn() })),
   }));

   // Create a mock builder for chained Supabase calls
   const createMockQueryBuilder = (data: any = null, error: any = null) => ({
     select: vi.fn().mockReturnThis(),
     insert: vi.fn().mockReturnThis(),
     update: vi.fn().mockReturnThis(),
     delete: vi.fn().mockReturnThis(),
     eq: vi.fn().mockReturnThis(),
     in: vi.fn().mockReturnThis(),
     gt: vi.fn().mockReturnThis(),
     gte: vi.fn().mockReturnThis(),
     order: vi.fn().mockReturnThis(),
     single: vi.fn().mockResolvedValue({ data, error }),
     then: vi.fn((resolve) => resolve({ data, error })),
   });

   vi.mock('@/integrations/supabase/client', () => ({
     supabase: {
       from: vi.fn(),
       rpc: vi.fn(),
     },
   }));
   ```

2. Create wrapper helper:
   ```typescript
   function createWrapper() {
     const queryClient = new QueryClient({
       defaultOptions: {
         queries: { retry: false, gcTime: 0 },
       },
     });
     return ({ children }: { children: ReactNode }) => (
       <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
     );
   }
   ```

3. Test suites to implement:

   **Loading state tests:**
   - "shows loading state initially"
   - "sets loading to false after fetch completes"
   - "shows loading when refetching (isFetching)"

   **Success fetch tests:**
   - "fetches schedules for authenticated user"
   - "returns empty array when no schedules exist"
   - "enriches schedules with template names"
   - "enriches schedules with student names"
   - "enriches schedules with class names"
   - "handles missing enrichment data gracefully"

   **PGRST205 handling tests:**
   - "returns empty array on PGRST205 error (table not found)"
   - "returns empty array when error message contains 'not find'"

   **Error handling tests:**
   - "sets isError true on fetch failure"
   - "exposes error object for UI display"

   **Cache behavior tests:**
   - "uses cached data on subsequent renders"
   - "refetches when user changes"

   **Mutation tests:**
   - "createSchedule invalidates cache after success"
   - "updateSchedule invalidates cache after success"
   - "deleteSchedule invalidates cache after success"
   - "generateTasks calls RPC function"

   **Auth guard tests:**
   - "does not fetch when user is null"
   - "returns empty schedules when not authenticated"

4. Key testing patterns:
   - Mock supabase.from to return different mock builders per table
   - Use Promise resolution to simulate parallel enrichment
   - Verify invalidateQueries called after mutations
   - Test PGRST205 error code specifically
  </action>
  <verify>
Run tests: `npm test -- --run src/hooks/useRecurringSchedules.test.tsx`
All tests should pass
Run full suite: `npm test -- --run`
All existing tests still pass
  </verify>
  <done>
useRecurringSchedules.test.tsx exists with 18+ tests covering loading states, enrichment, PGRST205 handling, error states, cache behavior, and mutations. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - No TypeScript errors
2. `npm test -- --run src/hooks/useRecurringSchedules.test.tsx` - All hook tests pass
3. `npm test -- --run` - All existing tests still pass
4. Verify parallel enrichment: Network tab should show templates/profiles/classes fetched concurrently
</verification>

<success_criteria>
- useRecurringSchedules.ts uses useQuery with queryKeys.recurringSchedules.list
- queryFn uses Promise.all for parallel enrichment (not sequential)
- PGRST205 error returns empty array (not throws)
- All CRUD mutations use invalidateQueries for cache sync
- Backward-compatible interface maintained (schedules, loading, fetchSchedules, createSchedule, updateSchedule, deleteSchedule, generateTasks)
- New properties exposed (isFetching, isError, error)
- Test suite has 18+ tests covering all scenarios
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-complex-hook-migration/11-02-SUMMARY.md`
</output>
