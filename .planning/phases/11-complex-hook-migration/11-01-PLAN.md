---
phase: 11-complex-hook-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useAssignments.ts
  - src/hooks/useAssignments.test.tsx
autonomous: true

must_haves:
  truths:
    - "User sees loading indicator when useAssignments fetches task instances"
    - "User sees cached task instances instantly on repeated navigation"
    - "getTaskInstances returns fresh data when filters change"
    - "getGroupProgress returns cached data within staleTime"
    - "Mutations invalidate relevant cache entries"
  artifacts:
    - path: "src/hooks/useAssignments.ts"
      provides: "React Query migrated utility hook"
      contains: "useQueryClient"
    - path: "src/hooks/useAssignments.test.tsx"
      provides: "Comprehensive test coverage"
      min_lines: 100
  key_links:
    - from: "src/hooks/useAssignments.ts"
      to: "src/lib/queries/keys.ts"
      via: "queryKeys.assignments import"
      pattern: "queryKeys\\.assignments"
    - from: "src/hooks/useAssignments.ts"
      to: "queryClient.fetchQuery"
      via: "on-demand cached queries"
      pattern: "queryClient\\.fetchQuery"
---

<objective>
Migrate useAssignments from useState/useCallback to React Query on-demand caching pattern.

Purpose: useAssignments is a utility hook (doesn't auto-fetch). Convert getTaskInstances and getGroupProgress to use queryClient.fetchQuery for caching benefits while keeping mutations as async functions with invalidateQueries.

Output:
- Migrated useAssignments.ts using queryClient.fetchQuery pattern
- Comprehensive test suite verifying caching, invalidation, and error handling
</objective>

<execution_context>
@/Users/haokunyang/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haokunyang/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-complex-hook-migration/11-RESEARCH.md

# Established patterns
@.planning/phases/10-simple-hook-migration/10-01-SUMMARY.md
@.planning/phases/10-simple-hook-migration/10-02-SUMMARY.md

# Files to modify
@src/hooks/useAssignments.ts
@src/lib/queries/keys.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate useAssignments to React Query on-demand pattern</name>
  <files>src/hooks/useAssignments.ts</files>
  <action>
Migrate useAssignments from useState to React Query on-demand caching:

1. Add imports:
   ```typescript
   import { useQueryClient } from "@tanstack/react-query";
   import { queryKeys } from "@/lib/queries/keys";
   ```

2. Replace `const [loading, setLoading] = useState(false);` with `const queryClient = useQueryClient();`

3. Modify `getTaskInstances` to use fetchQuery:
   ```typescript
   const getTaskInstances = useCallback(async (filters: {...}): Promise<TaskInstance[]> => {
     try {
       return await queryClient.fetchQuery({
         queryKey: queryKeys.assignments.instances({
           assigneeId: filters.assigneeId,
           date: filters.date,
           startDate: filters.startDate,
         }),
         queryFn: async () => {
           // Move existing query logic here
           let query = supabase
             .from("task_instances")
             .select("*")
             .order("scheduled_date", { ascending: true })
             .order("scheduled_time", { ascending: true });
           // ... rest of existing filter logic
           const { data, error } = await query;
           if (error) throw error;
           return data || [];
         },
         staleTime: 30 * 1000, // 30 seconds - task instances change frequently
       });
     } catch (error) {
       handleError(error, { component: 'useAssignments', action: 'fetch task instances', silent: true });
       return [];
     }
   }, [queryClient]);
   ```

4. Modify `getGroupProgress` to use fetchQuery:
   ```typescript
   const getGroupProgress = useCallback(async (groupId: string, date?: string) => {
     const targetDate = date || format(new Date(), "yyyy-MM-dd");
     try {
       return await queryClient.fetchQuery({
         queryKey: queryKeys.assignments.progress(groupId, targetDate),
         queryFn: async () => {
           // Move existing waterfall query logic here
           // Get group members, profiles, todayInstances, overdueInstances, catchupInstances
           // ... exact same logic as current implementation
           return { completed, total, members, overdueCount };
         },
         staleTime: 60 * 1000, // 1 minute - progress updates matter
       });
     } catch (error) {
       handleError(error, { component: 'useAssignments', action: 'get group progress', silent: true });
       return { completed: 0, total: 0, members: [], overdueCount: 0 };
     }
   }, [queryClient]);
   ```

5. Add cache invalidation to `createAssignment`:
   - After successful creation, add: `await queryClient.invalidateQueries({ queryKey: queryKeys.assignments.all });`

6. Add cache invalidation to `updateTaskStatus`:
   - After successful update, add: `await queryClient.invalidateQueries({ queryKey: queryKeys.assignments.all });`

7. Update return statement:
   - Keep `loading: false` for backward compatibility (utility hook is always "ready")
   - Consider adding `queryClient` to return for advanced cache management (optional)

Key patterns from research:
- Use fetchQuery (not useQuery) because this hook doesn't auto-fetch on mount
- Include filter parameters in query key to prevent stale data on filter change
- Short staleTime (30s for instances, 60s for progress) since data changes frequently
- Global error handler already configured in QueryClient - don't duplicate error toasts
  </action>
  <verify>
Run TypeScript compilation: `npx tsc --noEmit`
Verify no type errors in useAssignments.ts
  </verify>
  <done>
useAssignments.ts uses useQueryClient and fetchQuery for getTaskInstances and getGroupProgress, mutations invalidate cache, backward-compatible interface maintained
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useAssignments test suite</name>
  <files>src/hooks/useAssignments.test.tsx</files>
  <action>
Create comprehensive test suite for migrated useAssignments hook:

1. Create test file with proper setup:
   ```typescript
   import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
   import { renderHook, waitFor, act } from '@testing-library/react';
   import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
   import { ReactNode } from 'react';
   import { useAssignments } from './useAssignments';

   // Mock dependencies
   vi.mock('./useAuth', () => ({
     useAuth: vi.fn(),
   }));
   vi.mock('./use-toast', () => ({
     useToast: vi.fn(() => ({ toast: vi.fn() })),
   }));
   vi.mock('@/integrations/supabase/client', () => ({
     supabase: {
       from: vi.fn(() => ({
         select: vi.fn().mockReturnThis(),
         insert: vi.fn().mockReturnThis(),
         update: vi.fn().mockReturnThis(),
         delete: vi.fn().mockReturnThis(),
         eq: vi.fn().mockReturnThis(),
         in: vi.fn().mockReturnThis(),
         lt: vi.fn().mockReturnThis(),
         gte: vi.fn().mockReturnThis(),
         lte: vi.fn().mockReturnThis(),
         order: vi.fn().mockReturnThis(),
         single: vi.fn(),
       })),
     },
   }));
   ```

2. Create wrapper helper:
   ```typescript
   function createWrapper() {
     const queryClient = new QueryClient({
       defaultOptions: {
         queries: { retry: false, gcTime: 0 },
       },
     });
     return ({ children }: { children: ReactNode }) => (
       <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
     );
   }
   ```

3. Test suites to implement:

   **Initialization tests:**
   - "initializes with loading: false (utility hook always ready)"
   - "returns all expected functions"

   **getTaskInstances tests:**
   - "fetches task instances with assigneeId filter"
   - "fetches task instances with date filter"
   - "fetches task instances with date range (startDate, endDate)"
   - "returns empty array on error"
   - "caches results for same filter combination"
   - "fetches fresh data when filters change"

   **getGroupProgress tests:**
   - "fetches group progress with waterfall queries"
   - "defaults to today's date if not provided"
   - "returns default progress object on error"
   - "caches progress data for same groupId and date"

   **createAssignment tests:**
   - "creates assignment and returns data"
   - "invalidates assignments cache after creation"
   - "returns null if no user"
   - "handles errors gracefully"

   **updateTaskStatus tests:**
   - "updates task status to completed"
   - "invalidates cache after status update"
   - "shows success toast on completion"

   **Cache behavior tests:**
   - "fetchQuery uses cached data within staleTime"
   - "fetchQuery refetches after staleTime expires"

4. Key testing patterns:
   - Use `act()` when calling async functions that trigger state updates
   - Mock supabase responses for each scenario
   - Verify cache invalidation by checking queryClient.invalidateQueries was triggered
   - Test error boundaries don't break the hook
  </action>
  <verify>
Run tests: `npm test -- --run src/hooks/useAssignments.test.tsx`
All tests should pass
Run full suite: `npm test -- --run`
All 141+ tests should pass
  </verify>
  <done>
useAssignments.test.tsx exists with 15+ tests covering getTaskInstances, getGroupProgress, createAssignment, updateTaskStatus, and cache behavior. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - No TypeScript errors
2. `npm test -- --run src/hooks/useAssignments.test.tsx` - All hook tests pass
3. `npm test -- --run` - All existing tests still pass (141+)
4. Manual verification: useAssignments still works in app (if dev server running)
</verification>

<success_criteria>
- useAssignments.ts uses useQueryClient and fetchQuery for on-demand caching
- getTaskInstances uses queryKeys.assignments.instances with filter parameters
- getGroupProgress uses queryKeys.assignments.progress with groupId and date
- createAssignment and updateTaskStatus invalidate queryKeys.assignments.all
- Backward-compatible interface maintained (loading, createAssignment, getTaskInstances, updateTaskStatus, getGroupProgress)
- Test suite has 15+ tests covering all functions and cache behavior
- All tests pass (total count increases from 141)
</success_criteria>

<output>
After completion, create `.planning/phases/11-complex-hook-migration/11-01-SUMMARY.md`
</output>
