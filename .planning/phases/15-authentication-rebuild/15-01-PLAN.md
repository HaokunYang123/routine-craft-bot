---
phase: 15-authentication-rebuild
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/[timestamp]_create_handle_new_user_trigger.sql
  - src/hooks/useGoogleAuth.ts
  - src/hooks/useAuth.tsx
autonomous: true

must_haves:
  truths:
    - "Database trigger creates profile row atomically when user signs up via OAuth"
    - "Trigger creates profile with role=null (to be set by callback)"
    - "User's role selection persists through OAuth flow via redirect URL"
    - "onAuthStateChange subscription is properly cleaned up on unmount (AUTH-06)"
  artifacts:
    - path: "supabase/migrations/[timestamp]_create_handle_new_user_trigger.sql"
      provides: "Database trigger for atomic profile creation"
      contains: "handle_new_user"
    - path: "src/hooks/useGoogleAuth.ts"
      provides: "OAuth with role parameter"
      exports: ["useGoogleAuth"]
    - path: "src/hooks/useAuth.tsx"
      provides: "Auth state with proper cleanup"
      contains: "subscription.unsubscribe"
  key_links:
    - from: "useGoogleAuth.ts"
      to: "supabase.auth.signInWithOAuth"
      via: "redirectTo with role query param"
      pattern: "redirectTo.*role="
---

<objective>
Create the database trigger for atomic profile creation and enhance useGoogleAuth to pass role through OAuth flow.

Purpose: Foundation for the new authentication system - ensures profile exists immediately after OAuth (zero latency) and role is correctly assigned from user's selection.

Output: Database migration with `handle_new_user` trigger, enhanced `useGoogleAuth.ts` hook accepting role parameter.
</objective>

<execution_context>
@/Users/haokunyang/.claude/get-shit-done/workflows/execute-plan.md
@/Users/haokunyang/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-authentication-rebuild/15-RESEARCH.md

Source files to read:
@src/hooks/useGoogleAuth.ts
@src/hooks/useAuth.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create handle_new_user database trigger</name>
  <files>supabase/migrations/[timestamp]_create_handle_new_user_trigger.sql</files>
  <action>
Create a migration file that:

1. Drops any existing trigger/function (idempotent):
```sql
drop trigger if exists on_auth_user_created on auth.users;
drop function if exists public.handle_new_user();
```

2. Creates the `handle_new_user` function with:
   - Language: plpgsql
   - Security: `security definer set search_path = ''`
   - Logic:
     - Extract display_name from `new.raw_user_meta_data->>'full_name'` OR `new.raw_user_meta_data->>'name'` OR email prefix
     - Insert into public.profiles with role=NULL (to be set once by callback)
     - Use `on conflict (user_id) do nothing` to prevent duplicates if trigger fires twice
   - Return new

3. Creates the trigger:
   - After INSERT on auth.users
   - For each row
   - Execute procedure public.handle_new_user()

IMPORTANT: The trigger does NOT set role (leaves it null). The callback sets role ONCE.
This supports AUTH-10 (immutability): role cannot be CHANGED once set, but CAN be SET once from null.

Apply the migration using mcp__supabase__apply_migration tool.
  </action>
  <verify>
Use mcp__supabase__execute_sql to verify:
1. Function exists: `SELECT proname FROM pg_proc WHERE proname = 'handle_new_user';`
2. Trigger exists: `SELECT tgname FROM pg_trigger WHERE tgname = 'on_auth_user_created';`
3. Test trigger functionality by creating a test user and verifying profile creation:
   ```sql
   -- Use Supabase auth.admin to create test user (via Dashboard > Authentication > Add User)
   -- Or verify function logic directly:
   SELECT pg_get_functiondef(oid) FROM pg_proc WHERE proname = 'handle_new_user';
   ```
   Verify the function inserts with role=NULL (not a default value).
  </verify>
  <done>Database trigger `handle_new_user` exists, fires on auth.users INSERT, creates profile with role=null</done>
</task>

<task type="auto">
  <name>Task 2: Enhance useGoogleAuth to pass role in redirectTo</name>
  <files>src/hooks/useGoogleAuth.ts</files>
  <action>
Modify the useGoogleAuth hook to:

1. Change `signInWithGoogle` function signature to accept a role parameter:
   ```typescript
   const signInWithGoogle = useCallback(async (role: 'coach' | 'student') => {
   ```

2. Update the `signInWithOAuth` call to:
   - Pass role in the redirectTo URL as a query parameter
   - Include role in the user metadata via `data` option (Supabase stores this in raw_user_meta_data which trigger reads)

   ```typescript
   const { data, error: authError } = await supabase.auth.signInWithOAuth({
     provider: "google",
     options: {
       scopes: "profile email",
       redirectTo: `${window.location.origin}/auth/callback?role=${role}`,
       queryParams: {
         access_type: "offline",
         prompt: "consent",
       },
     },
   });
   ```

Note: The `data` option is NOT available in signInWithOAuth (only in signUp). We rely on:
- The redirect URL query parameter for callback handling
- The database trigger reading from raw_user_meta_data (which Google populates with name/email)

The role will be passed through the URL and handled in the callback page (Plan 02).

3. Keep the rest of the hook unchanged (loading, error state, clearError).
  </action>
  <verify>
1. TypeScript compiles without errors: `npm run build` (or check that vite build succeeds)
2. The function signature now requires a role parameter
  </verify>
  <done>useGoogleAuth.signInWithGoogle requires a role parameter and includes it in redirectTo URL</done>
</task>

<task type="auto">
  <name>Task 3: Verify onAuthStateChange cleanup (AUTH-06)</name>
  <files>src/hooks/useAuth.tsx</files>
  <action>
Verify that the existing useAuth.tsx properly cleans up the onAuthStateChange subscription.

Read `src/hooks/useAuth.tsx` and confirm:
1. The subscription is captured: `const { data: { subscription } } = supabase.auth.onAuthStateChange(...)`
2. The cleanup returns unsubscribe: `return () => subscription.unsubscribe();`

If cleanup is MISSING, add it following the pattern from 15-RESEARCH.md:
```typescript
useEffect(() => {
  const { data: { subscription } } = supabase.auth.onAuthStateChange(
    (event, session) => {
      // ... existing handler logic
    }
  );

  // ... existing getSession logic

  // CRITICAL: Cleanup subscription on unmount
  return () => {
    subscription.unsubscribe();
  };
}, []);
```

If cleanup is ALREADY present (expected based on current codebase), document confirmation in SUMMARY.
  </action>
  <verify>
1. Read useAuth.tsx and confirm `subscription.unsubscribe()` is called in cleanup
2. Pattern: `return () => subscription.unsubscribe();` or equivalent
  </verify>
  <done>useAuth.tsx has proper onAuthStateChange cleanup to prevent memory leaks (AUTH-06 satisfied)</done>
</task>

</tasks>

<verification>
1. Database trigger exists: `mcp__supabase__execute_sql` with query for trigger
2. Trigger function inserts with role=NULL (verify via pg_get_functiondef)
3. useGoogleAuth TypeScript compiles and requires role parameter
4. useAuth.tsx has `subscription.unsubscribe()` in cleanup
5. Build passes: `npm run build`
</verification>

<success_criteria>
- Database trigger `handle_new_user` is active on auth.users
- Trigger creates profiles with role=null (not a default value)
- useGoogleAuth.signInWithGoogle requires role parameter ('coach' | 'student')
- OAuth redirect URL includes role query parameter
- useAuth.tsx properly unsubscribes from onAuthStateChange (AUTH-06)
- No TypeScript errors in modified files
</success_criteria>

<output>
After completion, create `.planning/phases/15-authentication-rebuild/15-01-SUMMARY.md`
</output>
